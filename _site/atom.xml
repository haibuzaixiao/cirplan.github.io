<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>萝拔</title>
 <link href="jeffdeng.me/" rel="self"/>
 <link href="jeffdeng.me"/>
 <updated>2016-01-20T17:06:22+08:00</updated>
 <id>jeffdeng.me</id>
 <author>
   <name>dcirplan</name>
   <email>dcirplan@gmail.com</email>
 </author>

 
 <entry>
   <title>DOM ready原理</title>
   <link href="jeffdeng.me/web/2015/12/03/dom-ready"/>
   <updated>2015-12-03T00:00:00+08:00</updated>
   <id>jeffdeng.me/web/2015/12/03/dom-ready</id>
   <content type="html">
&lt;p&gt;&lt;code&gt;DOM ready&lt;/code&gt;这个已经有很多人说了，说的也很详细，这里简单说下。利用问题的形式展开～&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：为什么需要&lt;code&gt;dom ready&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;答：我们需要在页面加载后，再进行一些js操作，例如：绑定事件，操作DOM。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：为什么不用&lt;code&gt;window.onload&lt;/code&gt;事件？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;答：&lt;code&gt;window.onload&lt;/code&gt;要等页面内的所有资源都加载完才触发，像图片、音频等，等待的时间会比较长。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：那直接用&lt;code&gt;DOMContentLoaded&lt;/code&gt;就好，还墨迹这么多？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;答：&lt;code&gt;DOMContentLoaded&lt;/code&gt;本来是&lt;code&gt;FireFox&lt;/code&gt;的私有事件，FF3版本才完整支持，&lt;code&gt;webkit&lt;/code&gt;系列的在525版本后才增加这个事件的支持，IE系列的在IE9才开始支持。
可以看看它的兼容性，如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/1203dom/compatibility.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：IE在不支持&lt;code&gt;DOMContentLoaded&lt;/code&gt;事件的情况下，如何判断&lt;code&gt;DOM ready&lt;/code&gt;？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;方法一：往页面内添加&lt;code&gt;script&lt;/code&gt;标签，添加&lt;code&gt;defer&lt;/code&gt;属性，通过监听这个脚本的&lt;code&gt;readyState&lt;/code&gt;，当脚本加载完成时就判断&lt;code&gt;DOM ready&lt;/code&gt;了。&lt;/p&gt;

    &lt;p&gt;但这个方法的缺点是：当页面里有&lt;code&gt;iframe&lt;/code&gt;的时候，会等&lt;code&gt;iframe&lt;/code&gt;里所有的资源加载完才触发，和&lt;code&gt;onload&lt;/code&gt;差不多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法二：通过轮询来调用&lt;code&gt;document.documentElement.doScroll&lt;/code&gt;方法，调用成功表示&lt;code&gt;DOM ready&lt;/code&gt;了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，IE下用方法二来判断&lt;code&gt;DOM ready&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：&lt;code&gt;document.documentElement.doScroll&lt;/code&gt;是个什么鬼？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;答：IE下一些事件只有在DOM准备好后才能触发，&lt;code&gt;document.documentElement.doScroll&lt;/code&gt;就是这样一个事件。通过判断调用是否成功，进而判断DOM是否加载完。
这个hack最早是外国的大牛发现的，详情可以看&lt;a href=&quot;http://javascript.nwbox.com/IEContentLoaded/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：IE的判断完了，那&lt;code&gt;webkit&lt;/code&gt;系列的在525版本之前的怎么判断？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;答：通过轮询判断&lt;code&gt;document.readyState&lt;/code&gt;，当&lt;code&gt;readyState&lt;/code&gt;为&lt;code&gt;loaded/complete&lt;/code&gt;的时候，判断DOM加载完毕。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：你说的我都懂，有没有什么现成的库？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;答：基本上比较流行的库都有实现的，像&lt;code&gt;jQuery/Zepto/Prototype/Moontools/YUI&lt;/code&gt;等，只是每个库实现的方式都不同。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;github&lt;/code&gt;上也有个比较出名的库&lt;a href=&quot;https://github.com/ded/domready&quot;&gt;domready&lt;/a&gt;，现在它的主分支是针对有&lt;code&gt;DOMContentLoaded&lt;/code&gt;事件的浏览器，兼容性如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;IE9+&lt;/li&gt;
  &lt;li&gt;Firefox 4+&lt;/li&gt;
  &lt;li&gt;Safari 3+&lt;/li&gt;
  &lt;li&gt;Chrome *&lt;/li&gt;
  &lt;li&gt;Opera *&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过它的&lt;a href=&quot;https://github.com/ded/domready/releases/tag/v0.3.0&quot;&gt;0.3.0&lt;/a&gt;分支是兼容多种浏览器的，兼容性如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;IE6+&lt;/li&gt;
  &lt;li&gt;Firefox 2+&lt;/li&gt;
  &lt;li&gt;Safari 3+&lt;/li&gt;
  &lt;li&gt;Chrome *&lt;/li&gt;
  &lt;li&gt;Opera *&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section&quot;&gt;最后&lt;/h3&gt;

&lt;p&gt;如果是用在移动端的话，可以放心的通过&lt;code&gt;DOMContentLoaded&lt;/code&gt;事件来判断。PC的话，国内现在的环境，还是乖乖用兼容版本吧。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/JulyZhang/archive/2011/02/12/1952484.html&quot;&gt;http://www.cnblogs.com/JulyZhang/archive/2011/02/12/1952484.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Audio在移动端的实践</title>
   <link href="jeffdeng.me/web/2015/11/30/html5-audio"/>
   <updated>2015-11-30T00:00:00+08:00</updated>
   <id>jeffdeng.me/web/2015/11/30/html5-audio</id>
   <content type="html">
&lt;pre&gt;&lt;code&gt;好久没写blog了，有三点原因，一是懒，二是懒，三是懒。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为最近项目里面有个需求，要在移动端用web的&lt;code&gt;Audio&lt;/code&gt;实现音频播放。本想说臣妾做不到啊～然而，还是开始挖坑了。在这里记录下各种坑死人的问题。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;准备&lt;/h3&gt;

&lt;p&gt;先看兼容性（下图），可以看到在移动端上用是完全可行的（理论上）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20151130audio/compatibility.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们再分别看看audio提供的&lt;code&gt;属性，方法和事件&lt;/code&gt;：&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;属性&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20151130audio/params.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;方法&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20151130audio/way.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;事件&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20151130audio/event.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体的可以&lt;a href=&quot;http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp&quot;&gt;戳这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;实践&lt;/h3&gt;

&lt;p&gt;其实按照上面的方法，随便怎么写怎么玩都可以，但主要有以下几个问题要解决的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.预加载的问题；
2.加载进度条问题；
3.多个音频文件切换问题；
4.其他的兼容性问题。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;1.预加载的问题&lt;/h4&gt;

&lt;p&gt;我们先来看预加载的流程(如下)，先用&lt;code&gt;load&lt;/code&gt;去加载音频，当音频可以播放就会触发&lt;code&gt;canplay&lt;/code&gt;事件，表示加载已经完成，可以播放，完美。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20151130audio/patten1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是，理想和现实总是有区别的，在表现不一的手机上就有问题了。&lt;/p&gt;

&lt;p&gt;问题一：&lt;code&gt;load&lt;/code&gt;方法调用了没效果，根本没有加载音频，要调用&lt;code&gt;play&lt;/code&gt;方法才开始加载。&lt;/p&gt;

&lt;p&gt;问题二：在三星note3 和锤子T1手机上，有50%的几率预加载失败。如果预加载失败，要切换好几次&lt;code&gt;播放/暂停&lt;/code&gt;状态才开始加载播放，或者一直没反应。&lt;/p&gt;

&lt;p&gt;问题三：一般触发&lt;code&gt;load&lt;/code&gt;加载音频文件后，音频文件缓冲好会触发&lt;code&gt;canplay&lt;/code&gt;事件的。&lt;/p&gt;

&lt;p&gt;在安卓下，触发&lt;code&gt;canplay&lt;/code&gt;事件，会有下面问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;360浏览器&lt;/code&gt;的&lt;code&gt;audio.seekable&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;uc浏览器，魅族自带浏览器，微信&lt;/code&gt;的&lt;code&gt;audio.buffered.length&lt;/code&gt;居然为0；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在iOS下，有以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;canplay&lt;/code&gt;事件触发后，微信&lt;code&gt;的audio.seekable&lt;/code&gt;为 &lt;code&gt;false&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;safari&lt;/code&gt;在&lt;code&gt;load&lt;/code&gt;了之后，&lt;code&gt;canplay&lt;/code&gt;事件不触发，点击&lt;code&gt;play&lt;/code&gt;后才触发 （9.1版本是正常的）；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看到这里是不是觉得坑大了，想逃？不要急，接着看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面问题总的来说有俩个，一个是加载进度，另外一个就是播放Bug了。这里主要说下问题二的解决方法。&lt;/p&gt;

&lt;p&gt;调用&lt;code&gt;load&lt;/code&gt;事件后，对加载进度进行检测，如果直到&lt;code&gt;canplay&lt;/code&gt;触发，加载进度一直为0，就判断为预加载失败。然后在点击播放的，设置进度&lt;code&gt;audio.currentTime = 1;&lt;/code&gt;，这样就会再次触发加载。这里还有个问题，如果是用&lt;code&gt;zepto&lt;/code&gt;的&lt;code&gt;tap&lt;/code&gt;监听点击播放事件，可以再次加载，但一直不播放，要监听&lt;code&gt;touchend&lt;/code&gt;这些事件才行（这个问题纠结N久）。
这样调整后，在三星note 3 和锤子T1这些有问题的手机上基本没什么问题了。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;2.加载进度条问题&lt;/h4&gt;

&lt;p&gt;加载进度，浏览器提供了&lt;code&gt;progress&lt;/code&gt;事件，但这个事件会有一些小问题，所以采用setInterval的去实行。正常来说在&lt;code&gt;canplay&lt;/code&gt;的时候显示进度条：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;onCanplay: function () {
    this.seekable = this.audio.seekable &amp;amp;&amp;amp; this.audio.seekable.length &amp;gt; 0;

    if ( this.seekable ) {
        this.timer = setInterval(this.onProgress.bind(this), 500);
    }

    var name = this.list[this.index].name || &#39;&#39;,
        time = this.list[this.index].time || &#39;&#39;;

    this.trigger(&#39;canplay&#39;, time, name, this.list[this.index]);
},

onProgress: function () {
    if ( this.audio &amp;amp;&amp;amp; this.audio.buffered !== null &amp;amp;&amp;amp; this.audio.buffered.length ) {
        this.duration = this.audio.duration === Infinity ? null : this.audio.duration;
        this.load_percent = ((this.audio.buffered.end(this.audio.buffered.length - 1) / this.duration) * 100).toFixed(4);
        if (isNaN(this.load_percent)) {
            this.load_percent = 0;
        }

        if ( this.load_percent &amp;gt;= 100 ) {
            this.clearLoadProgress();
        }

        this.trigger(&#39;progress&#39;, this.load_percent);
    }
},

// 对于play触发后才开始加载
play: function () {
    if (!this.seekable) {
        this.timer = setInterval(this.onProgress.bind(this), 500);
    }
    this.audio.play();
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码的逻辑主要是检测audio的&lt;code&gt;buffered&lt;/code&gt;，因为不同浏览器对buffered的解析不同，如果跳跃播放，有的会产生多段buffered，所以获取最新的缓存要这样：&lt;code&gt;this.audio.buffered.end(this.audio.buffered.length - 1)&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;3.多音频切换问题&lt;/h4&gt;

&lt;p&gt;在播放列表里，有多个音频文件，点击可以切换。正常的做法是，用&lt;code&gt;tap&lt;/code&gt;绑定点击事件，事件内部这样处理：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;audio.pause();
audio.setAttribute(&#39;src&#39;, url);
audio.play();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在PC的chrome上是很正常的，完美。但是，在手机上就嗝屁了。问题为：偶发性的出现，切换音频后，直接触发音频的&lt;code&gt;ended&lt;/code&gt;事件，然后再怎么切换&lt;code&gt;播放/点击&lt;/code&gt;都是无效的了。
这个问题的解决方法很简单，就是在&lt;code&gt;canplay&lt;/code&gt;触发的时候再触发&lt;code&gt;play&lt;/code&gt;就好，不要切换了音频url马上&lt;code&gt;play&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_t.audioHandler.on(&#39;canplay&#39;, function (totalTime, name) {
    _t.audioHandler.play();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为没有预加载的过程，每次都是点击列表的音频才播放，所以这样理论上是可行的。但是如果点击了播放，触发了加载，马上就点暂停，这时候&lt;code&gt;canplay&lt;/code&gt;还没触发，会不会有问题？&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;4.其他的兼容性问题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;关于音频的总时间，理论来说，正常加载的情况，在&lt;code&gt;canplay&lt;/code&gt;的时候是可以读取到的，但因为上面一堆&lt;code&gt;load&lt;/code&gt;问题，所以音频总时间要手动设置。&lt;/li&gt;
  &lt;li&gt;用&lt;code&gt;tab&lt;/code&gt;去绑定播放事件好像会有奇葩的问题，用&lt;code&gt;touch&lt;/code&gt;系列又太灵敏了，都接受不了可以用&lt;code&gt;fastclick&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;暂时还没发生其他问题，下面就看看例子吧。例子分两个，一个是单音频预加载播放，另外一个是多音频列表播放（UI直接用项目的了）。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;例子1：单音频预加载播放&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20151130audio/audio1.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;例子2：多音频切换播放&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20151130audio/audio2.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面俩个例子的代码在&lt;a href=&quot;https://github.com/cirplan/audioPlayer/tree/master/example&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-11&quot;&gt;最后&lt;/h3&gt;

&lt;p&gt;实践都这里就算完了。不过&lt;a href=&quot;http://www.cnblogs.com/Wayou/p/3543577.html&quot;&gt;这里&lt;/a&gt;有个更好玩的东西，有兴趣可以看看，非常酷炫。&lt;/p&gt;

&lt;p&gt;在开发的过程中，针对移动端，参考了&lt;a href=&quot;https://github.com/zohararad/audio5js&quot;&gt;Audio5js&lt;/a&gt;，整理出了个&lt;code&gt;audio&lt;/code&gt;的库。代码在&lt;a href=&quot;https://github.com/cirplan/audioPlayer&quot;&gt;这里&lt;/a&gt;，有兴趣可以关注下。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://dengo.org/archives/1048&quot;&gt;http://dengo.org/archives/1048&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/alongken2005/article/details/44569981&quot;&gt;http://blog.csdn.net/alongken2005/article/details/44569981&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://my.oschina.net/tommyfok/blog/202234?fromerr=ECkffV18&quot;&gt;http://my.oschina.net/tommyfok/blog/202234?fromerr=ECkffV18&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>前端文档整理</title>
   <link href="jeffdeng.me/web/2015/10/26/web-file"/>
   <updated>2015-10-26T00:00:00+08:00</updated>
   <id>jeffdeng.me/web/2015/10/26/web-file</id>
   <content type="html">
&lt;p&gt;本文主要是整理一些前端文档，以及别人整理的比较好的文档。&lt;/p&gt;

&lt;p&gt;本文内容：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot;&gt;代码规范&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#js-1&quot;&gt;JS文档&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#nodejs&quot;&gt;Node.js&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#section-1&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section&quot;&gt;1. 规范&lt;/h3&gt;

&lt;h4 id=&quot;web&quot;&gt;1.1 Web&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Isobar 前端代码规范 及 最佳实践&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;英文版：&lt;a href=&quot;https://github.com/isobar-idev/code-standards/&quot;&gt;https://github.com/isobar-idev/code-standards/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;中文版：&lt;a href=&quot;http://coderlmn.github.io/code-standards/&quot;&gt;http://coderlmn.github.io/code-standards/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;js&quot;&gt;1.2 JS&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Airbnb JavaScript Style Guide&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;英文版：&lt;a href=&quot;https://github.com/airbnb/javascript&quot;&gt;https://github.com/airbnb/javascript&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;中文版：&lt;a href=&quot;https://github.com/sivan/javascript-style-guide&quot;&gt;https://github.com/sivan/javascript-style-guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;js-1&quot;&gt;2. JS文档&lt;/h3&gt;

&lt;h4 id=&quot;promise-a&quot;&gt;2.1 Promise A+&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;英文版：&lt;a href=&quot;https://promisesaplus.com/&quot;&gt;https://promisesaplus.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;amd&quot;&gt;2.2 AMD规范&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;英文版: &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;https://github.com/amdjs/amdjs-api/wiki/AMD&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;中文版: &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)&quot;&gt;https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;cmd&quot;&gt;2.3 CMD规范&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;中文版: &lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;https://github.com/seajs/seajs/issues/242&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;angularjs&quot;&gt;2.4 AngularJS最佳实践&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;英文版: &lt;a href=&quot;https://github.com/mgechev/angularjs-style-guide/blob/master/README.md&quot;&gt;https://github.com/mgechev/angularjs-style-guide/blob/master/README.md&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;中文版: &lt;a href=&quot;https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md&quot;&gt;https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nodejs&quot;&gt;3. Node.js&lt;/h3&gt;

&lt;h3 id=&quot;stream-handbook&quot;&gt;3.1 stream-handbook&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;英文版: &lt;a href=&quot;https://github.com/substack/stream-handbook&quot;&gt;https://github.com/substack/stream-handbook&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;中文版: &lt;a href=&quot;https://github.com/jabez128/stream-handbook&quot;&gt;https://github.com/jabez128/stream-handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;4. 其他（别人的一些总结）&lt;/h3&gt;

&lt;h4 id=&quot;web-1&quot;&gt;4.1 腾讯移动Web前端知识库&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;中文版: &lt;a href=&quot;https://github.com/AlloyTeam/Mars&quot;&gt;https://github.com/AlloyTeam/Mars&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jtyjty99999-&quot;&gt;4.2 jtyjty99999 收集的移动开发的资源和技巧&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;中文版: &lt;a href=&quot;https://github.com/jtyjty99999/mobileTech&quot;&gt;https://github.com/AlloyTeam/Mars&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jacksontian--frontend-knowledge-structure&quot;&gt;4.3 JacksonTian 整理的前端技能汇总 Frontend Knowledge Structure&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;中文版: &lt;a href=&quot;https://github.com/JacksonTian/fks&quot;&gt;https://github.com/AlloyTeam/Mars&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;最后修改时间为：2015-11-17 修改次数1&lt;/code&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>JS模块化开发（3）：require.js的使用以及压缩策略</title>
   <link href="jeffdeng.me/js/2015/10/19/js-requirejs"/>
   <updated>2015-10-19T00:00:00+08:00</updated>
   <id>jeffdeng.me/js/2015/10/19/js-requirejs</id>
   <content type="html">
&lt;p&gt;&lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;是遵循AMD规范的模块加载器，这里简单说说其用法和压缩策略。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;本文内容：&lt;/h2&gt;

&lt;p&gt;1.基本使用&lt;/p&gt;

&lt;p&gt;2.如何打包压缩&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基本使用&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1 加载&lt;/h3&gt;

&lt;p&gt;要使用require.js前提当然是先下载好或引入CDN。若下载好后，直接引入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script data-main=&quot;index&quot; src=&quot;/js/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里表示引入require.js后，把index.js作为程序的主模块，加载并执行。如果怕页面阻塞，可以把这段代码放到页面底部。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2 定义主模块&lt;/h3&gt;

&lt;p&gt;定义主模块可以使用&lt;code&gt;require&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// main.js
require([&#39;moduleA&#39;, &#39;moduleB&#39;, &#39;moduleC&#39;], function (moduleA, moduleB, moduleC){
    // some code here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用常规的定义模块的方式，用&lt;code&gt;define&lt;/code&gt;定义，因为&lt;code&gt;data-main&lt;/code&gt;已经指定这个是主模块了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// main.js
define([&#39;moduleA&#39;, &#39;moduleB&#39;, &#39;moduleC&#39;], function (moduleA, moduleB, moduleC){
    // some code here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但有一种情况是一定要使用&lt;code&gt;require&lt;/code&gt;定义的，下面会说到。&lt;/p&gt;

&lt;h3 id=&quot;requirejs&quot;&gt;1.3 require.js配置&lt;/h3&gt;

&lt;p&gt;利用&lt;code&gt;require.config()&lt;/code&gt;，对require.js进行基本配置，&lt;code&gt;require.config()&lt;/code&gt;要放在主模块的头部，主要作用如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义基本目录；&lt;/li&gt;
  &lt;li&gt;对常用模块定义别名，方便引用；&lt;/li&gt;
  &lt;li&gt;定义文件版本号；&lt;/li&gt;
  &lt;li&gt;处理非AMD规范的模块；&lt;/li&gt;
  &lt;li&gt;处理非AMD规范并对其他模块产生依赖的模块；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// require.js config
require.config({
    baseUrl: &#39;/common/js&#39;, // 定义基本目录
    urlArgs: &#39;v=1.1.0&#39;,  // 定义请求js文件版本号
    paths: { // 常用模块别名
        &#39;angular&#39;    : &#39;lib/angular.min&#39;,
        &#39;sanitize&#39;   : &#39;lib/angular-sanitize.min&#39;,
        &#39;zepto&#39;      : &#39;lib/zepto.min&#39;
    },

    // 若加载模块不符合AMD规范，直接返回全局变量，则用下面方式封装
    // 切记：exports的变量一定要和返回的 全局变量名称 一致
    shim: {
        &#39;angular&#39;: {
	        exports: &#39;angular&#39;
        },
        &#39;sanitize&#39;: { // 对非AMD规范，对其他模块产生依赖依赖的要加上
	        deps: [&#39;angular&#39;],
	        exports: &#39;Sanitize&#39;
         },
        &#39;zepto&#39;: {
	       exports: &#39;Zepto&#39;
       }
    }

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个就是一个很常规的require.config配置。但在实际开发中，我们是不会把这段配置加在每个主模块的头部的，不然要修改点东西，就要一个一个改，岂不是要死的心都有。&lt;/p&gt;

&lt;p&gt;一般把上面的配置信息提成一个公共js，在require.js加载前加载。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;/js/config.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script data-main=&quot;index/index&quot; src=&quot;/js/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但如果直接把上面这段配置放在&lt;code&gt;config.js&lt;/code&gt;里会报&lt;code&gt;require is undefined&lt;/code&gt;。想想也是，require.js都还没有加载。所以我们修改下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// require.js config
var require = {
    baseUrl: &#39;/common/js&#39;, // 定义基本目录
    urlArgs: &#39;v=1.1.0&#39;,  // 定义请求js文件版本号
    paths: { // 常用模块别名
        &#39;angular&#39;    : &#39;lib/angular.min&#39;,
        &#39;sanitize&#39;   : &#39;lib/angular-sanitize.min&#39;,
        &#39;zepto&#39;      : &#39;lib/zepto.min&#39;
    },

    // 若加载模块不符合AMD规范，直接返回全局变量，则用下面方式封装
    // 切记：exports的变量一定要和返回的 全局变量名称 一致
    shim: {
        &#39;angular&#39;: {
	        exports: &#39;angular&#39;
        },
        &#39;sanitize&#39;: { // 对非AMD规范，对其他模块产生依赖依赖的要加上
	        deps: [&#39;angular&#39;],
	        exports: &#39;Sanitize&#39;
         },
        &#39;zepto&#39;: {
	       exports: &#39;Zepto&#39;
       }
    }

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就ok啦，现在可以想怎么折腾就怎么折腾了。&lt;/p&gt;

&lt;h3 id=&quot;amd&quot;&gt;1.4 AMD模块写法&lt;/h3&gt;

&lt;p&gt;关于AMD模块的定义，上一篇有介绍。直接定义在&lt;code&gt;define&lt;/code&gt;函数中。如我们要定义url模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// url.js
define(function (){
　　var getId = function (key) {
	    ...
    };

　　return {
       getId: getId
　　};
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// main.js
require([&#39;url&#39;], function (url){
　　alert(url.getId(&#39;index&#39;));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若定义有依赖的模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&#39;util&#39;], function(util){
    function each(){
        util.doSomething();
        ...
    }
    return {
       each : each
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;2.如何打包压缩&lt;/h2&gt;

&lt;p&gt;由于使用模块化，文件会被分成很多个，这样在浏览器端无疑会产生很多HTTP请求，会让用户的等待时间加长。对于这个问题，require.js也提出了用&lt;code&gt;r.js&lt;/code&gt;合并压缩的方案。下面介绍r.js的使用。&lt;/p&gt;

&lt;p&gt;使用r.js要安装node.js环境，未安装的自行安装。&lt;/p&gt;

&lt;h3 id=&quot;rjs&quot;&gt;2.1 下载r.js&lt;/h3&gt;

&lt;p&gt;直接下载戳&lt;a href=&quot;http://requirejs.org/docs/release/2.1.11/r.js&quot;&gt;这里&lt;/a&gt;。或者直接用npm 安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g requirejs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2.2 文件目录&lt;/h3&gt;

&lt;p&gt;下面是示例的test目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test
    -html
        -index.html
    -dist
    -js
        -index
            -index.js
            -index2.js
        -lib
            -require.js
            -zepto.js
        -util
            -common.js
            -url.js
        -config.js
    -r.js
    -build.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;r.js&lt;/code&gt;放在根目录，&lt;code&gt;build.js&lt;/code&gt;为压缩配置文件，&lt;code&gt;dist&lt;/code&gt;为压缩后的输出目录。下面为对应js文件的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// index.js
define([&#39;zepto&#39;, &#39;index/index2&#39;, &#39;url&#39;], function($, index2, url){
    console.log(&#39;index&#39;);
});

// index2.js
define([&#39;url&#39;, &#39;util/common&#39;], function(url, common){
    console.log(&#39;index2&#39;);
});

// common.js
define([], function(){
    console.log(&#39;common&#39;);
});

// url.js
define([&#39;zepto&#39;], function($){
    console.log(&#39;url&#39;);
});

// config.js
var require = {
    baseUrl: &quot;../js&quot;,
    paths: {
        &quot;zepto&quot;: &quot;lib/zepto&quot;,
        &quot;url&quot;: &quot;util/url&quot;
    },
    shim: {
        &#39;zepto&#39;:{
        　　exports: &#39;Zepto&#39;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们来看看如何压缩。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需求1&lt;/strong&gt; 把index.js及其依赖项合并压缩成一个js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;({
    baseUrl: &#39;./js&#39;,  // 设置基本目录
    optimize: &#39;none&#39;, // 压缩方式：不压缩
    // path和shim配置要和config.js一样
    paths: { 
　　　　　　&quot;zepto&quot;: &quot;lib/zepto&quot;,
　　　　　　&quot;url&quot;: &quot;util/url&quot;
　　 },

    shim: {
        &#39;zepto&#39;:{
        　　exports: &#39;Zepto&#39;
        }
    },

    name: &#39;index/index&#39;, //设置要压缩的单个文件
    out : &#39;js/index/index-build.js&#39; // 设置要输出的文件名
})	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在命令行进入到项目的根目录，执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node r.js -o build.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以看到在index目录下会生成新的文件，其中最后一部分为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
  ;[&#39;swipe&#39;, &#39;swipeLeft&#39;, &#39;swipeRight&#39;, &#39;swipeUp&#39;, &#39;swipeDown&#39;, &#39;doubleTap&#39;, &#39;tap&#39;, &#39;singleTap&#39;, &#39;longTap&#39;].forEach(function(m){
    $.fn[m] = function(callback){ return this.bind(m, callback) }
  })
})(Zepto)
;
define(&quot;zepto&quot;, (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Zepto;
    };
}(this)));

define(&#39;url&#39;,[&#39;zepto&#39;], function($){
	console.log(&#39;url&#39;);
});
define(&#39;util/common&#39;,[], function(){
	console.log(&#39;common&#39;);
});
define(&#39;index/index2&#39;,[&#39;url&#39;, &#39;util/common&#39;], function(url, common){
	console.log(&#39;index2&#39;);
});
define(&#39;index/index&#39;,[&#39;zepto&#39;, &#39;index/index2&#39;, &#39;url&#39;], function($, index2, url){
	console.log(&#39;index&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;需求2&lt;/strong&gt; 把index.js和index2.js批量分别合并&lt;/p&gt;

&lt;p&gt;因为在实际开发中很难像上面一个一个合并，所以批量合并是比较好得方法。修改build.js如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;({
    baseUrl: &#39;./js&#39;,  // 设置基本目录
    dir: &#39;./dist&#39;, // 设置输出目录
    optimize: &#39;none&#39;, // 压缩方式：不压缩
    // path和shim配置要和config.js一样
    paths: { 
　　　　　　&quot;zepto&quot;: &quot;lib/zepto&quot;,
　　　　　　&quot;url&quot;: &quot;util/url&quot;
　　 },

    shim: {
        &#39;zepto&#39;:{
        　　exports: &#39;Zepto&#39;
        }
    },

    modules : [
        {
            name: &#39;index/index&#39;
        },

        {
            name: &#39;index/index2&#39;
        }
    ]
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样会在&lt;code&gt;dist&lt;/code&gt;目录下生成一系列文件，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20151019requirejs/out1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于module数组里不要求合并的js，是和原来一样的。&lt;/p&gt;

&lt;p&gt;调用直接调用这样就这样了，config.js都不用加载了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script data-main=&quot;../dist/index/index.js&quot; src=&quot;../js/lib/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;需求3&lt;/strong&gt; 把zepto.js和url.js等公用文件合并成一个文件，index.js和index2.js如果有依赖这些文件时的，在合并的时候自动忽略&lt;/p&gt;

&lt;p&gt;因为把所有页面的js都压缩成一个，公用的部分每次都加载，未免会增加等待时间，所以把公用部分抽出来是一个比较好的选择。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;({
    baseUrl: &#39;./js&#39;,  // 设置基本目录
    dir: &#39;./dist&#39;, // 设置输出目录
    optimize: &#39;none&#39;, // 压缩方式：不压缩
    // path和shim配置要和config.js一样
    paths: { 
　　　　　　&quot;zepto&quot;: &quot;lib/zepto&quot;,
　　　　　　&quot;url&quot;: &quot;util/url&quot;
　　 },

    shim: {
        &#39;zepto&#39;:{
        　　exports: &#39;Zepto&#39;
        }
    },

    modules : [
        {
            name: &#39;lib/common&#39;,
            create: true,
            include: [&#39;zepto&#39;, &#39;url&#39;]
        },

        {
            name: &#39;index/index&#39;,
            exclude: [
                &#39;zepto&#39;,
                &#39;url&#39;
            ]
        },

        {
            name: &#39;index/index2&#39;,
            exclude: [
                &#39;zepto&#39;,
                &#39;url&#39;
            ]
        }
    ]
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到&lt;code&gt;dist/lib&lt;/code&gt;下生成了&lt;code&gt;common.js&lt;/code&gt;，而index.js变成了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// index.js
define(&#39;util/common&#39;,[], function(){
	console.log(&#39;common&#39;);
});
define(&#39;index/index2&#39;,[&#39;url&#39;, &#39;util/common&#39;], function(url, common){
	console.log(&#39;index2&#39;);
});
require([&#39;zepto&#39;, &#39;index/index2&#39;, &#39;url&#39;], function($, index2, url){
	console.log(&#39;index&#39;);
});
define(&quot;index/index&quot;, function(){});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改&lt;code&gt;config.js&lt;/code&gt;如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var require = {
    baseUrl: &quot;../js&quot;,
    paths: {
        &quot;zepto&quot;: &quot;../dist/lib/common&quot;,
        &quot;url&quot;: &quot;../dist/lib/common&quot;
    },

    shim: {
        &#39;zepto&#39;:{
        　　exports: &#39;Zepto&#39;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后直接请求:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;../js/config.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script data-main=&quot;../dist/index/index.js&quot; src=&quot;../js/lib/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就有公用模块了。更多r.js的配置看&lt;a href=&quot;https://github.com/jrburke/r.js/blob/master/build/example.build.js&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果觉得requrejs压缩后还是很大，可以尝试使用require.js作者的另一个开源项目&lt;a href=&quot;https://github.com/jrburke/almond&quot;&gt;almond.js&lt;/a&gt;。almond.js压缩后最小为1k左右。
但有一个很重要的限制：所有模块必须压缩在一个文件里。almond.js的使用可以看&lt;a href=&quot;http://levi.yii.so/archives/3450&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最后，选择哪种压缩策略看项目的具体需要。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>JS模块化开发（2）：AMD与CMD规范</title>
   <link href="jeffdeng.me/js/2015/10/18/js-amd-cmd"/>
   <updated>2015-10-18T00:00:00+08:00</updated>
   <id>jeffdeng.me/js/2015/10/18/js-amd-cmd</id>
   <content type="html">
&lt;p&gt;接着&lt;a href=&quot;/js/2015/10/17/js-module/&quot;&gt;上一篇&lt;/a&gt;，这里说下AMD与CMD规范。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;本文内容：&lt;/h2&gt;

&lt;p&gt;1.AMD规范&lt;/p&gt;

&lt;p&gt;2.CMD规范&lt;/p&gt;

&lt;p&gt;3.AMD规范CMD规范的异同点&lt;/p&gt;

&lt;h2 id=&quot;amdrequirejs&quot;&gt;1.AMD规范（代表require.js）&lt;/h2&gt;

&lt;p&gt;AMD规范的英文文档看&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;这里&lt;/a&gt;，中文版看&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)&quot;&gt;这里&lt;/a&gt;（选择细看文档的话，下面不用看了）。AMD全称是Asynchronous Module Definition（异步模块定义规范），规定了模块与模块之间是异步加载的，
这和浏览器的异步加载模块的环境刚好适应（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题）。&lt;/p&gt;

&lt;p&gt;该规范只定义了一个全局函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(id?, dependencies?, factory);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;id-&quot;&gt;id 名字&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;类型：字符串；&lt;/li&gt;
  &lt;li&gt;特点：唯一，可选，默认为脚本名字。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dependencies-&quot;&gt;dependencies 依赖&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;类型：数组；&lt;/li&gt;
  &lt;li&gt;执行顺序：依赖模块必须根据模块的工厂方法优先级执行（依赖少的先执行），并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中；&lt;/li&gt;
  &lt;li&gt;模块命名：如果是相对的，应该解析为相对定义中的模块。&lt;/li&gt;
  &lt;li&gt;关键字： 三种特殊的依赖关键字&lt;code&gt;require&lt;/code&gt;,&lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;，是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。
然而，如果工厂方法的形参个数小于3，加载器会选择以函数指定的参数个数调用工厂方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建一个名为”alpha”的模块，使用了require，exports，和名为”beta”的模块:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&quot;alpha&quot;, [&quot;require&quot;, &quot;exports&quot;, &quot;beta&quot;], function (require, exports, beta) {
   exports.verb = function() {
       return beta.verb();
       //Or:
       return require(&quot;beta&quot;).verb();
   }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;factory-&quot;&gt;factory 工厂方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;类型：函数或对象；&lt;/li&gt;
  &lt;li&gt;特点：函数只执行一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个没有依赖性的模块可以直接定义对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define({
  add: function(x, y){
    return x + y;
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;commonjs-&quot;&gt;简单的 CommonJS 转换&lt;/h3&gt;

&lt;p&gt;为了向CommonJS靠拢而加的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function (require, exports, module) {
 var a = require(&#39;a&#39;),
     b = require(&#39;b&#39;);

 exports.action = function () {};
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这会被转换成规范模式再执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&quot;a&quot;, &quot;b&quot;], function (a, b) {
  	...
    exports.action = function () {};
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在require.js（v2.1.20 line2052）中的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//If no name, and callback is a function, then figure out if it a
//CommonJS thing with dependencies.
if (!deps &amp;amp;&amp;amp; isFunction(callback)) {
    deps = [];
    //Remove comments from the callback string,
    //look for require calls, and pull them into the dependencies,
    //but only if there are function args.
    if (callback.length) {
        callback
            .toString()
            .replace(commentRegExp, &#39;&#39;)
            .replace(cjsRequireRegExp, function (match, dep) {
                deps.push(dep);
            });

        //May be a CommonJS thing even without require calls, but still
        //could use exports, and module. Avoid doing exports and module
        //work though if it just needs require.
        //REQUIRES the function to expect the CommonJS variables in the
        //order listed below.
        deps = (callback.length === 1 ? [&#39;require&#39;] : [&#39;require&#39;, &#39;exports&#39;, &#39;module&#39;]).concat(deps);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但在某些情况下，因为脚本大小的限制或函数不支持toString方法（Opera Mobile是已知的不支持函数的toString方法），模块加载器可以选择扫描不扫描依赖性。
如果有依赖参数，模块加载器不应该在工厂方法中扫描依赖性。&lt;/p&gt;

&lt;h2 id=&quot;cmdseajs&quot;&gt;2.CMD规范（代表sea.js）&lt;/h2&gt;

&lt;p&gt;CMD(Common Module Definition)规范戳&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;这里&lt;/a&gt;。该规范规定一个模块就是一个文件，定义的函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(factory);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;define是全局函数；&lt;/li&gt;
  &lt;li&gt;factory可以是一个函数，也可以是一个对象或字符串；&lt;/li&gt;
  &lt;li&gt;factory为函数时，默认传入三个参数：&lt;code&gt;require&lt;/code&gt;、&lt;code&gt;exports&lt;/code&gt; 和 &lt;code&gt;module&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {
  // 模块代码
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CMD也支持如下写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(id?, deps?, factory)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串 id 表示模块标识，数组 deps 是模块依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&#39;hello&#39;, [&#39;jquery&#39;], function(require, exports, module) {
  // 模块代码
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，带 id 和 deps 参数的 define 用法不属于 CMD 规范，而属于 &lt;a href=&quot;https://github.com/cmdjs/specification/blob/master/draft/transport.md&quot;&gt;Modules/Transport&lt;/a&gt; 规范。&lt;/p&gt;

&lt;p&gt;下面分别说说&lt;code&gt;require&lt;/code&gt;，&lt;code&gt;exports&lt;/code&gt;，&lt;code&gt;module&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;require&quot;&gt;require&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;require&lt;/code&gt;是 factory 函数的第一个参数，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {

  // 获取模块 a 的接口
  var a = require(&#39;./a&#39;);

  // 调用模块 a 的方法
  a.doSomething();

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;require.async&lt;/code&gt; require.async(id, callback?) 方法用来在模块内部异步加载模块，并在加载完成后执行指定回调。callback 参数可选。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {

  // 异步加载一个模块，在加载完成时，执行回调
  require.async(&#39;./b&#39;, function(b) {
    b.doSomething();
  });

  // 异步加载多个模块，在加载完成时，执行回调
  require.async([&#39;./c&#39;, &#39;./d&#39;], function(c, d) {
    c.doSomething();
    d.doSomething();
  });

});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;exports&quot;&gt;exports&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;exports&lt;/code&gt;是一个对象，用来向外提供模块接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {

  // 对外提供 foo 属性
  exports.foo = &#39;bar&#39;;

  // 对外提供 doSomething 方法
  exports.doSomething = function() {};

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了给 exports 对象增加成员，还可以使用 return 直接向外提供接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require) {

  // 通过 return 直接提供接口
  return {
    foo: &#39;bar&#39;,
    doSomething: function() {}
  };

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示：exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。&lt;/p&gt;

&lt;h3 id=&quot;module&quot;&gt;module&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;module&lt;/code&gt; 是一个对象，上面存储了与当前模块相关联的一些属性和方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;module.exports&lt;/code&gt; 当前模块对外提供的接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {

  // exports 是 module.exports 的一个引用
  console.log(module.exports === exports); // true

  // 重新给 module.exports 赋值
  module.exports = new SomeClass();

  // exports 不再等于 module.exports
  console.log(module.exports === exports); // false

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：对 module.exports 的赋值需要同步执行，不能放在回调函数里。下面这样是不行的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// x.js
define(function(require, exports, module) {

  // 错误用法
  setTimeout(function() {
    module.exports = { a: &quot;hello&quot; };
  }, 0);

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CMD经常使用的 API 只有 &lt;code&gt;define, require, require.async, exports, module.exports&lt;/code&gt; 这五个。其他请看规范。&lt;/p&gt;

&lt;h2 id=&quot;amdcmd&quot;&gt;3.AMD规范CMD规范的异同点&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;相同点&lt;/h3&gt;

&lt;p&gt;AMD与CMD的相同点是：都是 &lt;strong&gt;异步提前加载&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// AMD 
define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) { 
   //在此时模块a和b都已加载完
});

// CMD
define(function(require, exports, module) {
    //在此时模块a和b都已加载完
    var a = require(&#39;./a&#39;); 
    a.doSomething();
	...

    var b = require(&#39;./b&#39;);
    b.doSomething();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;不同点&lt;/h3&gt;

&lt;p&gt;而两者的区别，在上一篇中的AMD和CommonJS的区别已经说了一部分。玉伯在&lt;a href=&quot;http://www.zhihu.com/question/20351507/answer/14859415&quot;&gt;知乎&lt;/a&gt;也有回答，或者看&lt;a href=&quot;https://github.com/seajs/seajs/issues/277&quot;&gt;这里&lt;/a&gt;。主要有俩个，一个是执行时机不同，还有一个是书写风格不同。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.执行时机&lt;/h4&gt;

&lt;p&gt;AMD是 &lt;strong&gt;提前执行&lt;/strong&gt;，CMD是 &lt;strong&gt;延迟执行&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// AMD 
define([&#39;./a&#39;], function(a) { 
    // 在这之前a已经执行完并返回
    a.doSomething()；
	...
});

// CMD
define(function(require, exports, module) {
    var a = require(&#39;./a&#39;); // 模块a在此时才执行
    a.doSomething();
	...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;2.书写风格&lt;/h4&gt;

&lt;p&gt;CMD 推崇&lt;strong&gt;依赖就近&lt;/strong&gt;，AMD 推崇&lt;strong&gt;依赖前置&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// CMD
define(function(require, exports, module) {
    var a = require(&#39;./a&#39;);
    a.doSomething();
    // 此处略去 100 行
    var b = require(&#39;./b&#39;); // 依赖可以就近书写
    b.doSomething();
    // ... 
});

// AMD 默认推荐的是
define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) { // 依赖必须一开始就写好
    a.doSomething();
    // 此处略去 100 行
    b.doSomething();
    ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt;

&lt;p&gt;选择AMD还是CMD要看项目的需求和自己对写法的偏好，并没有绝对说哪个比哪个好。require.js成名较早，人气比较高。sea.js小而优雅，
文档支持也比较好，国内还是有比较多人使用的。&lt;/p&gt;

&lt;p&gt;下面介绍&lt;code&gt;require.js&lt;/code&gt;的使用，请看下一篇：&lt;a href=&quot;/js/2015/10/19/js-requirejs/&quot;&gt;require.js的使用以及压缩策略&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>JS模块化开发（1）：历史</title>
   <link href="jeffdeng.me/js/2015/10/17/js-module"/>
   <updated>2015-10-17T00:00:00+08:00</updated>
   <id>jeffdeng.me/js/2015/10/17/js-module</id>
   <content type="html">
&lt;pre&gt;&lt;code&gt;开篇感言：一直以来懒散的很，以为想改就改，无须过于在意。但现在发现懒散的态度已经融到骨子里了，还能改否？曰：难。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;前言：&lt;/h3&gt;

&lt;p&gt;JS模块化在现在早已不是一个新鲜的词语，随便在网络上搜一下都有一大堆文献资料，简单的、详细的应有尽有。
而我最近才开始关注这方面，没有见证到09年以来COMMOMJS标准的诞生，AMD和CMD的崛起，未免是一个遗憾。
所以这里整理下JS模块化的发展历程。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;本文内容：&lt;/h3&gt;

&lt;p&gt;1.为什么需要模块化&lt;/p&gt;

&lt;p&gt;2.模块化的发展历程&lt;/p&gt;

&lt;p&gt;3.AMD和CommonJS的区别&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.为什么需要模块化&lt;/h3&gt;

&lt;p&gt;为什么需要模块化，玉伯大大的这篇&lt;a href=&quot;https://github.com/seajs/seajs/issues/547&quot;&gt;前端模块化开发的价值&lt;/a&gt;应该很好解答你的疑问。
文章中提到的两点：&lt;code&gt;命名冲突&lt;/code&gt;和&lt;code&gt;文件依赖&lt;/code&gt;问题的确是JS一直以来的痛处。由与JS是10天内诞生的，所以没有其他高大上编程语言尽善尽美的模块管理机制。
但不管这是作者的刻意为之还是兼顾不到，从ES6的规范来看，模块化已经是大势所趋了。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.1命名冲突&lt;/h4&gt;

&lt;p&gt;JS是一门容错性很高的语言，定义变量不需要定义类型，对于重复的命名既不会报错也不会停止执行。看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 重复声明
var a = 1;
var a;
console.log(a); // 1

// 重复声明&amp;amp;赋值
var a = 1;
var a = 2;
console.log(a); // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子很好理解，JS的变量是先声明再赋值的，所以对于重复声明是没有影响的。但重复赋值就会把之前的值覆盖掉。如果在团队开发中，我无心把你的覆盖了，
你无意把我写的覆盖了，等合并代码后，觉得整个码生都是灰暗的。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;1.2模块依赖&lt;/h4&gt;

&lt;p&gt;模块依赖在项目不大，或者不算复杂的情况还不算什么问题。但当项目代码数量上来了，管理模块依赖简直要命。最古老的方法就是人肉依赖：什么？引入这个
JS文件报错了？之前不是用的没问题吗？应该是出BUG了，看下谁写的，叫他来看看……如果你是作者对于这样的事情是不是觉得有点无奈，不由地感叹：时间都去哪了。
当然，可以在JS文件的头注释上把要依赖的文件列出来。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;1.3常规处理&lt;/h4&gt;

&lt;p&gt;既然这俩个问题早就有了，那之前是怎么处理的呢？控制好作用域&amp;amp;采用自执行函数生成对象。参考阮一峰老师的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/javascript_module.html&quot;&gt;Javascript模块化编程（一）：模块的写法&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a.常规的对象生成方法：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var module1 = new Object({
	_count : 0,

	m1 : function (){
	　　　//...
	},

	m2 : function (){
	//...
	}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在一定程度上减少变量的重复命名，调用直接 &lt;code&gt;module1.m1()&lt;/code&gt; 就可以了。但缺点也很明显，可以直接修改对象内部的属性，模块之间看不出关联。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b.采用立即执行函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var module1 = (function(){
　　var _count = 0;
　　var m1 = function(){
　　　　//...
　　};
　　var m2 = function(){
　　　　//...
　　};
　　return {
　　　　m1 : m1,
　　　　m2 : m2
　　};
})();
console.info(module1._count); //undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样对象内部属性就修改不了。但这样看不出模块之间的依赖。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c.输入全局变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;显式地将其他变量输入模块，可以明确模块依赖。ex：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var module1 = (function ($, YAHOO) {
　　//...
})(jQuery, YAHOO);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在没有模块加载器的情况下，这样算是比较好的解决方案了。一方面限制了变量作用域，另外显示把依赖输入模块，一目了然。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.模块化的发展历程&lt;/h3&gt;

&lt;p&gt;参考玉伯的&lt;a href=&quot;https://github.com/seajs/seajs/issues/588&quot;&gt;前端模块化开发那点历史&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在2009年，ServerJS诞生了，其社区推出&lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules&quot;&gt;Modules/1.0&lt;/a&gt;规范，Node.js采用部分该规范并获得不错的效果。ex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = require(&#39;./a&#39;)  // 加载模块（同步加载）
a.doSomething()         // 等上一句执行完才会执行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ServerJS为了把这套规范推到浏览器端，就改名叫做CommonJS，同时激烈争论Modules的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：&lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;Modules/1.x&lt;/strong&gt; 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Transport&quot;&gt;Modules/Transport&lt;/a&gt; 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 &lt;a href=&quot;https://github.com/componentjs/component&quot;&gt;component&lt;/a&gt; 和走在前沿的 &lt;a href=&quot;https://github.com/esnext/es6-module-transpiler&quot;&gt;es6 module transpiler&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;2.&lt;strong&gt;Modules/Async&lt;/strong&gt; 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition&quot;&gt;AMD&lt;/a&gt; 规范及其实现 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;3.&lt;strong&gt;Modules/2.0&lt;/strong&gt; 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 &lt;a href=&quot;https://code.google.com/p/bravojs/&quot;&gt;BravoJS&lt;/a&gt; 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 &lt;a href=&quot;http://www.page.ca/~wes/CommonJS/modules-2.0-7/&quot;&gt;Modules/2.0-draft&lt;/a&gt; 规范花了很多心思。FlyScript 的作者提出了 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Wrappings&quot;&gt;Modules/Wrappings&lt;/a&gt; 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。&lt;/p&gt;

&lt;h3 id=&quot;amdcommonjs&quot;&gt;3.AMD和CommonJS的区别&lt;/h3&gt;

&lt;h4 id=&quot;section-7&quot;&gt;1.执行时机有区别&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Modules/1.0:
var a = require(&quot;./a&quot;) // 执行到此时，a.js 才同步下载并执行

// AMD:
define([&quot;a&quot;], function(a) {
  // 在这里，模块 a 已经下载并执行好
  // ...

})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AMD 里提前下载 a.js 是浏览器的限制，没办法做到同步下载，这个社区都认可。但执行，AMD 里是 Early Executing，Modules/1.0 里是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的也不能接受。这个差异，也导致实质上 Node 的模块与 AMD 模块是无法共享的，存在潜在冲突。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;2.模块书写风格有争议&lt;/h4&gt;

&lt;p&gt;AMD 风格下，通过参数传入依赖模块，破坏了 &lt;strong&gt;就近声明&lt;/strong&gt; 原则。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) {

    // 等于在最前面申明并初始化了要用到的所有模块

   if (false) {
       // 即便压根儿没用到某个模块 b，但 b 还是提前执行了
       b.foo()
   }

})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有就是 AMD 下 require 的用法，以及增加了全局变量 define 等细节，当时在社区被很多人不认可。&lt;/p&gt;

&lt;p&gt;最后，AMD 从 CommonJS 社区独立了出去，单独成为了 AMD 社区。这样的结局不免的让人唏嘘不已。&lt;/p&gt;

&lt;p&gt;下一篇：&lt;a href=&quot;/js/2015/10/18/js-amd-cmd/&quot;&gt;AMD与CMD的规范&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/547&quot;&gt;https://github.com/seajs/seajs/issues/547&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/588&quot;&gt;https://github.com/seajs/seajs/issues/588&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://huangxuan.me/2015/05/25/js-module-loader/&quot;&gt;JavaScript Module Loader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>穿越东西冲</title>
   <link href="jeffdeng.me/trip/2015/09/19/cross"/>
   <updated>2015-09-19T00:00:00+08:00</updated>
   <id>jeffdeng.me/trip/2015/09/19/cross</id>
   <content type="html">
&lt;p&gt;周三的时候突然想去东西冲穿越，然后约了朋友，周六果断去了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;路线&lt;/h2&gt;

&lt;p&gt;我们是先坐地铁到竹子林，然后到福田交通枢纽公交站（就在地铁站旁边）坐H92公交车到大鹏。因为是首发站，所以车上会有很多位置。刷深圳通是11块，如果给钱的话是13块。&lt;/p&gt;

&lt;p&gt;到大鹏途中大概要两个小时左右，到了大鹏，可以选择去东冲还是去西冲。去西冲有1号线和2号线两个入口。我们是下了H92再坐232小巴到西冲的2号线。&lt;/p&gt;

&lt;p&gt;到了西冲，入口每个人要收13块。继续走就到了西冲的沙滩边，然后往左边就是去东冲的方向了。&lt;/p&gt;

&lt;p&gt;到了东冲可以坐231小巴回大鹏。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;物品&lt;/h2&gt;

&lt;p&gt;首先长袖，长裤，帽子什么的都是很有必要的！很有必要！很有必要！可以适当涂点防晒霜（因为我穿短袖短裤，没有帽子，然后裸露的皮肤全都晒伤了，红通通的，一摸就疼，哭）。防晒一定要做好！&lt;/p&gt;

&lt;p&gt;然后我们还买了手套，事实证明手套也是很有必要的，因为你要不断的攀岩啊（不骗人）。一副好的手套可以让穿越过程的难度降低30%左右～&lt;/p&gt;

&lt;p&gt;其他最重要的是水，因为穿越途中是没有水买的。我们三个人，买了两瓶大的和三瓶小的矿泉水，差不多喝完。其他吃的可以自己看心情选购，有一点是：在穿越过程中是不想吃东西的，最好在启程的时候就吃掉。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;时间&lt;/h2&gt;

&lt;p&gt;我们是12点12分从西冲开始出发（正是最晒的时候），到东冲的时候，是下午4点19分。历时4个小时零7分，算是比较正常的时间吧。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;看图时刻&lt;/h1&gt;

&lt;p&gt;由于是用手机拍的，图片质量不是很好（没错，我还压缩了）。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;西冲&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;往东冲的方向&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;开始&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;第一个小山头&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;在休息&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;另外一个很陡的小山头&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/12.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;又一个小山头&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/14.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-11&quot;&gt;后面的山&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/15.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/16.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-12&quot;&gt;全景&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/17.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/19.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-13&quot;&gt;从上面滚着下来&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/20.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;地面时刻&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/21.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-15&quot;&gt;好想游泳&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/22.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-16&quot;&gt;全景2&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/23.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-17&quot;&gt;回望&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/24.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-18&quot;&gt;过不去了&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/25.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-19&quot;&gt;回望&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/26.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-20&quot;&gt;山顶&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/27.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/28.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-21&quot;&gt;大海&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/30.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-22&quot;&gt;终点–东冲&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/31.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-23&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;如果让有经验的人带一下会安全很多，一个人走会比较危险。整个过程还是刺激又好玩的，比爬山好玩多了，但没爬山安全踏实。时间要安排好，不然走到中间天黑了就麻烦了。周末会比较多人，大部分都是从东冲到西冲。跟着大部队的话不会走上歪路。&lt;/p&gt;

&lt;p&gt;恩，刺激，好玩。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>canvas分辨率问题</title>
   <link href="jeffdeng.me/js/2015/07/06/canvas-resolution"/>
   <updated>2015-07-06T00:00:00+08:00</updated>
   <id>jeffdeng.me/js/2015/07/06/canvas-resolution</id>
   <content type="html">
&lt;p&gt;过程：最近尝试用H5的canvas写了个小游戏，然后加载图片的时候发现，在电脑上图片是很清晰的，但到了手机上就看到比较模糊（图片都是实际大小的2倍）。&lt;/p&gt;

&lt;p&gt;再现：demo代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.onload = function () {
	var canvas = document.getElementById(&#39;canvas1&#39;);
	var ctx = canvas.getContext(&quot;2d&quot;);
	var width, height;
	width = 320;
	height = 568;

	canvas.style.width = width+&#39;px&#39;;
	canvas.style.height = height + &#39;px&#39;;
	canvas.width = width; 
	canvas.height = height;
	var img = new Image();
	img.src = &quot;../img/s6_1.png&quot;;
	img.onload = function () {  
	    ctx.drawImage(img, 20, 20, img.width/2, img.height/2); 
	}  
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先看效果图（左边为电脑模拟，右边为手机）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/1_pc.png&quot; alt=&quot;电脑&quot; /&gt;
&lt;img src=&quot;/images/2015/20150706canvas/2_phone.jpg&quot; alt=&quot;手机&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有没有发现什么？认真看就会发现：右边的图比较模糊（如果实在没发现请自戳双目，为什么？因为留着没用）。&lt;/p&gt;

&lt;p&gt;所以现在问题是：&lt;code&gt;为什么canvas加载图片在手机上会显示模糊？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先我们看看上面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;canvas.style.width = width+&#39;px&#39;;
canvas.style.height = height + &#39;px&#39;;
canvas.width = width; 
canvas.height = height;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样子写是不是有点多此一举了？闲的蛋疼？为了证明不是蛋疼，首先我们要了解&lt;code&gt;设备像素&lt;/code&gt;和&lt;code&gt;CSS像素&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;css&quot;&gt;设备像素和CSS像素&lt;/h3&gt;

&lt;p&gt;设备像素就是我们平时所说的设备真实像素，像iPhone5s的 640 x 1136。但一般开发者是不怎么关心这个数值的，因为有CSS像素。&lt;/p&gt;

&lt;p&gt;CSS像素是我们平时代码直接用的，iPhone5s的CSS像素为 320 x 568（这样子应该懂了吧）。&lt;/p&gt;

&lt;p&gt;由于设备像素和CSS像素不一样，所以设备会用几个设备像素表示一个CSS像素。像iPhone5s就是4个设备像素点表示一个CSS像素。如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/3_px.gif&quot; alt=&quot;像素比例&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里就有一个很常见的问题：为什么图片在retina屏中会模糊？&lt;/p&gt;

&lt;p&gt;例如要显示 100px x 100px 的图片，如果切出来的图片也是 100px x 100px，那么在iPhone5s下是肯定会模糊的。
因为iPhone5s的 设备像素/CSS像素 比是2。所以它需要的图片实际大小为 200px x 200px。如果像现在这样大小不够呢？那像素点只能被扩充了。&lt;/p&gt;

&lt;p&gt;什么是扩充？就是5s的4个设备像素点表示1个CSS像素点时候，本应该4个像素点都有各自的颜色的，但图片小了，那4个设备像素点都是复制成同一种颜色。十分简单粗暴的方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;canvas的显示也是类似于图片，如果不够大就会被扩充。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;canvas.width/height&lt;/code&gt; 表示的是设备像素，而 &lt;code&gt;canvas.style.width/height&lt;/code&gt; 表示的是CSS像素。所以设置&lt;code&gt;canvas.width/height==canvas.style.width/height&lt;/code&gt;的时候，如果 设备像素/CSS像素 不是1，canvas就被扩充了，然后图片加载进去，虽然是2倍实际大小，但还是模糊掉了（这里没想通？再想想）。这样就很好解析刚刚的例子在电脑端没有模糊（我的电脑像素比是1），但在手机端却模糊了（还不明白？不是我的问题就是你的问题了）。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;解决方法&lt;/h3&gt;

&lt;p&gt;既然问题出现了，总是会有解决方法的。先看两个参数 &lt;code&gt;devicePixelRatio&lt;/code&gt;和&lt;code&gt;webkitBackingStorePixelRatio&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;devicepixelratio&quot;&gt;devicePixelRatio&lt;/h4&gt;

&lt;p&gt;devicePixelRatio是window下的属性，是 设备像素/CSS像素 的比值。下面列出了一些：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;iPhone5s 		2&lt;/li&gt;
  &lt;li&gt;iPhone6 plus  3&lt;/li&gt;
  &lt;li&gt;nexus7 		1.3 (非常奇葩)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个参数比较简单直观，不用多说。其实在chrome模拟手机浏览的时候，也有这个参数的，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/4_pc_px.png&quot; alt=&quot;chrome模拟像素比&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中红色框中的就是这个像素比。&lt;/p&gt;

&lt;h4 id=&quot;webkitbackingstorepixelratio&quot;&gt;webkitBackingStorePixelRatio&lt;/h4&gt;

&lt;p&gt;webkitBackingStorePixelRatio是存在canvas context中（仅safari和chrome），该属性的值决定了浏览器在渲染canvas之前会用几个像素来存储画布信息。
例如，在iOS6 safari中这个值为2，它要渲染 100px x 100px 的图片，首先会在内存中生成一张200x200的图片，然后浏览器渲染的时候，会按100x100的图片来渲染，
因此就变成了200x200，正好和内存中的图片大小一致，因此在iOS的safari中不会出现失真的问题（有点绕口，慢慢理解）。&lt;/p&gt;

&lt;p&gt;但是在iOS7 的safari中这个值又变成了1，是出于性能的考虑，详情可以看&lt;a href=&quot;http://asciiwwdc.com/2013/sessions/600&quot;&gt;这里&lt;/a&gt;，搜索关键字‘backing’。&lt;/p&gt;

&lt;p&gt;知道了这俩个参数，那接下来怎么玩？实践是检验真理的唯一标准。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;实践&lt;/h3&gt;

&lt;p&gt;修改之前的代码，把像素比加进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var PIXEL_RATIO = (function () {
    var ctx = document.createElement(&quot;canvas&quot;).getContext(&quot;2d&quot;),
        dpr = window.devicePixelRatio || 1,
        bsr = ctx.webkitBackingStorePixelRatio ||
              ctx.mozBackingStorePixelRatio ||
              ctx.msBackingStorePixelRatio ||
              ctx.oBackingStorePixelRatio ||
              ctx.backingStorePixelRatio || 1;

    return dpr / bsr;
})();

window.onload = function () {
	var canvas = document.getElementById(&#39;canvas1&#39;);
	var ctx = canvas.getContext(&quot;2d&quot;);
	var width, height;
	width = 320;
	height = 568;

	canvas.style.width = width+&#39;px&#39;;
	canvas.style.height = height + &#39;px&#39;;
	canvas.width = width * PIXEL_RATIO; 
	canvas.height = height * PIXEL_RATIO;
	var img = new Image();
	img.src = &quot;../img/s6_1.png&quot;;
	img.onload = function () {  
	    ctx.drawImage(img, 20, 20, img.width/2, img.height/2); 
	}  
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看效果（左边为之前效果，右边为修改后效果）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/1_pc.png&quot; alt=&quot;之前&quot; /&gt;
&lt;img src=&quot;/images/2015/20150706canvas/5_pc.png&quot; alt=&quot;之后&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现了什么？图居然缩小了！我滴天，这是为什么？认真想想问题出在哪里。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;因为CSS像素点被缩放了&lt;/code&gt;，为什么会缩放？因为它是大爷，它想缩所以缩了。&lt;/p&gt;

&lt;p&gt;所以解决方案是对canvas进行缩放，下面是完整版代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var PIXEL_RATIO = (function () {
	    var ctx = document.createElement(&quot;canvas&quot;).getContext(&quot;2d&quot;),
	        dpr = window.devicePixelRatio || 1,
	        bsr = ctx.webkitBackingStorePixelRatio ||
	              ctx.mozBackingStorePixelRatio ||
	              ctx.msBackingStorePixelRatio ||
	              ctx.oBackingStorePixelRatio ||
	              ctx.backingStorePixelRatio || 1;

	    return dpr / bsr;
})();

window.onload = function () {
	var canvas = document.getElementById(&#39;canvas1&#39;);
	var ctx = canvas.getContext(&quot;2d&quot;);
	var width, height;
	width = 320;
	height = 568;

	canvas.style.width = width+&#39;px&#39;;
	canvas.style.height = height + &#39;px&#39;;
	canvas.width = width * PIXEL_RATIO; 
	canvas.height = height * PIXEL_RATIO;

	ctx.scale(PIXEL_RATIO, PIXEL_RATIO);

	var img = new Image();
	img.src = &quot;../img/s6_1.png&quot;;
	img.onload = function () {  
	    ctx.drawImage(img, 20, 20); 
	}  
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;左边是电脑之前模拟的效果，右边是电脑现在模拟的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/1_pc.png&quot; alt=&quot;之前电脑&quot; /&gt;
&lt;img src=&quot;/images/2015/20150706canvas/7_pc.png&quot; alt=&quot;之后电脑&quot; /&gt;&lt;/p&gt;

&lt;p&gt;左边是手机之前的效果，右边是手机现在的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/2_phone.jpg&quot; alt=&quot;之前手机&quot; /&gt;
&lt;img src=&quot;/images/2015/20150706canvas/8_ph.jpg&quot; alt=&quot;之后手机&quot; /&gt;&lt;/p&gt;

&lt;p&gt;嗯，基本的解决方案就是这样。如果有问题，可以提出来～&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/laijingyao881201/article/details/39505043&quot;&gt;http://blog.csdn.net/laijingyao881201/article/details/39505043&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/canvas/hidpi/&quot;&gt;http://www.html5rocks.com/en/tutorials/canvas/hidpi/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>2015展望</title>
   <link href="jeffdeng.me/%E7%94%9F%E6%B4%BB/2015/01/08/plan"/>
   <updated>2015-01-08T00:00:00+08:00</updated>
   <id>jeffdeng.me/%E7%94%9F%E6%B4%BB/2015/01/08/plan</id>
   <content type="html">
&lt;p&gt;TP:008D7BD6&lt;/p&gt;

&lt;p&gt;新的一年，总得写点什么，例如立下些雄心壮志的目标之类。虽然最后往往都是不了了之，但还是可以很装的说一句：立过。&lt;/p&gt;

&lt;p&gt;这一年大目标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;做好毕设项目。&lt;/li&gt;
  &lt;li&gt;多看书。&lt;/li&gt;
  &lt;li&gt;多锻炼。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先说说现在的情况。&lt;/p&gt;

&lt;p&gt;毕设已经开始做，采用的是nodejs+mysql+backbone，基本框架已经搭好。但整个流程还没想好，导致数据库的表也还没建完。4月20多号就要做完（今年真的是变态的早），然后答辩。这样一想，时间还是挺紧迫的。赶紧赶紧~&lt;/p&gt;

&lt;p&gt;虽然时间比较紧，首先还是要把功能想清楚的，把流程划分好模块。然后把表建好。再把基本的框架完善，然后堆业务就好了（想的是不是太简单了）。&lt;/p&gt;

&lt;p&gt;然后说看书的吧。14年基本没怎么看书，技术不升反降。现在工作这么久，又懒的看书，都是够用就好（囧~）。&lt;/p&gt;

&lt;p&gt;好把，今年要看100+本书！咳咳，开玩笑的啦。技术书籍的话，就把已经买了的技术书看完就好了。因为我对技术书籍毫无抵抗力啊，每次看到好书就毫不犹豫的买回来，拿到书时候那个开心啊！但是！买回来居然不看，就放在那里养老。然后又把书架堆的满满的！每次别人看到，都一脸膜拜的样子，搞得我超级不好意思哎，一半我都没看过的啊~搞得每次我都想把书藏好！&lt;/p&gt;

&lt;p&gt;然后非技术的书也要看的，买kindle就是为了看这些书的。反正今年的目标就是：看看看~当然，不能为了看书而看书，该思考的还是得思考，该记录的还是得记录。可不能像完成任务一样刷刷刷。&lt;/p&gt;

&lt;p&gt;再说说技术吧，前端今年肯定是要搞的比较通透了的，毕竟接触前端也有三年了差不多，但现在还是属于无脑编码型。很多东西没有去总结，就一直没有得到应有的提高。懒得要命的毛病，今年得改~然后nodejs也是要学的，虽然也接触了挺久了，但一直在做简单的小demo，还没有深入去学习，加入自己的理解。数据库也得看，操作系统，算法导论，编译原理等等（一想到这么多的大部头，真不知道自己为啥那么高兴的买回来）。总得来说，还是得定下心来，去看书，去实践。&lt;/p&gt;

&lt;p&gt;锻炼的话，多跑步，多爬山。少吃零食，多睡觉。就酱。&lt;/p&gt;

&lt;p&gt;希望到了2016，总结我的2015，是：充实+技术。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>2014年回顾</title>
   <link href="jeffdeng.me/%E7%94%9F%E6%B4%BB/2015/01/04/year-review"/>
   <updated>2015-01-04T00:00:00+08:00</updated>
   <id>jeffdeng.me/%E7%94%9F%E6%B4%BB/2015/01/04/year-review</id>
   <content type="html">
&lt;p&gt;2015年匆匆的赶来了，100秒钟都不多给，好坏的。&lt;/p&gt;

&lt;p&gt;时间过的，一般快。对于过得充实的人来说，时间还好，游刃有余。对于我，
时间就像把我牢牢绑在几百万牛顿推力的火箭上，一路上了拉着我啊啊啊啊的往前冲，或者有时候
还没啊出来，时间就把我带过去了。一回头，发现离原地越来越远。好吧，又扯淡了。&lt;/p&gt;

&lt;p&gt;先看看&lt;a href=&quot;/2014/02/20/plan.html&quot;&gt;14年的计划&lt;/a&gt;，这篇文章是14年2月20号写的。不知不觉写了快一年，感觉就像在昨天，好快啊。又扯淡了，打手！&lt;/p&gt;

&lt;p&gt;14年的计划是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;换mx3，买kindle，买台1500左右的山地车，买台mac pro，去海南环岛。&lt;/li&gt;
    &lt;li&gt;锻炼身体，走百公里。&lt;/li&gt;
    &lt;li&gt;奋斗。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;那一年过去了，哪些实现了？你觉得哪些可以实现？上面说买各种东西说的是用自己赚的钱买的。说这个的时候才大三开学，对前途一片渺茫。我都不知道怎么突然会有这样的想法。当时和我姐说过，我姐轻轻的说，不现实~其实有愿望还是好的，如果最后没有实现，但这个愿望毕竟在一段时间里给过你力量。&lt;/p&gt;

&lt;p&gt;恩，结果是没有买mx3，不过买了mx4，kindle也买了。山地车没有买，也没有去海南环岛（好遗憾）。&lt;s&gt;mac pro 也准备买了，就等等师兄过HK（我没有办通行证啊摔）&lt;/s&gt;最后还是没有买，用着公司的mini。&lt;/p&gt;

&lt;p&gt;然后3月份开始还是有锻炼的，然后去走了传说中百公里。对于我这样虚弱的存在，你觉得走了多少公里呢？什么，至少99公里？恩，我计划也是这样的。然后事实是~~走了40多公里而已，从深圳湾开始一直走到梧桐山。从晚上6点左右出发，一直走到第二天早上7点多。虽然大脑一直在鞭笞我前进前进前进，但腿还是很诚实的啊，牢牢的粘在地上迈不起来，捂脸。&lt;/p&gt;

&lt;p&gt;由于第一次，没经验，走到最后凌晨3、4点的时候真的好累好累，又饿，腿一动就疼，这个时候真的好想家啊！我要妈妈，我要回家！当时真想挂在树上不走了，但又是在偏僻的地方，不走下去没人接啊。只能继续迈着小短腿，扭着小屁股左摇右摆的挪下去。不过，万幸的是脚没有出泡泡，也没有抽筋。然后也没有低血糖的感觉（还是年轻过的，虽然经常低血糖，囧）。&lt;/p&gt;

&lt;p&gt;其实后来想想，还是很害怕的，因为如果有什么突发意外，腿抽筋啊什么的，真的完全没有考虑到。后来那么累，又没有实物补充，要是晕倒怎么办。只能说，不想那么多反而没问题。年轻就是战胜一切的法宝。&lt;/p&gt;

&lt;p&gt;还有就是回来的时候坐公交，超级多人，还要排队，都累趴了还排队？没办法，只能一脸要死的样子像僵尸一样跟在队伍后面。上了公交还要站，好吧，看到外面还在排队的人，我认了。还好到了地铁就有位置了。迷迷糊糊瞌睡了一路~记得当时有个小女孩，用她很好奇的眼睛看着我们打瞌睡的样子，觉得好困惑呢。哈哈~&lt;/p&gt;

&lt;p&gt;然后暑假到现在，基本是没什么运动了。自从实习了，肚腩也越发嚣张！摔摔摔！&lt;/p&gt;

&lt;p&gt;然后就考完试就到暑假啦，啦啦啦~终于不用上课了。最重要的是，这个学期不仅把挂的课修回来，还没有挂科。对于每个学期必挂一科的我，真的很难得。&lt;/p&gt;

&lt;p&gt;然后就出去找实习了。恩，还不错，之前有个来学校校招，招应届毕业生做H5的，但我凭借出色的人格魅力征服了他们，最后还是同意让我去实习（其实面试得一塌糊涂）。但由于公司和我预期有点出入，最后还是没有去。&lt;/p&gt;

&lt;p&gt;然后去了另外一家创业公司。去这家公司真的很巧合，因为我是在技术论坛上找的。那个时候，我还年轻，经常逛技术论坛，哦，看的最多的是当然八卦事情。然后加入了个技术QQ群，然后公司的老板在里面招人，我就顺理成章的进来了。后来，做了一个半月，到8月31号，公司资金撑不住了，终于要倒闭了。好伤感，那一瞬~后来大家一起看了个《分手大师》，吃了顿饭就说拜拜了。伤感~还是珍惜现在和你一起奋斗的人吧，说不定什么时候就说拜拜了。&lt;/p&gt;

&lt;p&gt;没了工作，就在宿舍宅了十几天。专心做全宇宙最宅的宅男。因为8月尾的时候，做了阿里的网上测试，通知过广州面试。但觉得自己技术一般般，又懒的过去就拒了。这个时候应该有点伤感。&lt;/p&gt;

&lt;p&gt;后来，前公司同事把我叫到了现在这家新的创业公司。又开始每天coding的生活啦~&lt;/p&gt;

&lt;p&gt;恩。国庆的时候，回去拜山。在山上，砍掉杂草的时候，由于早餐没吃饱，运动过快，血糖供应不上，一头栽到地上，断片了。人生第一次断片哦，超激动，原来真有断片~说这个，只是想说经常低血糖的要时刻关注自己身体的情况。发现不对，马上蹲下来。管他那么多，蹲蹲蹲。&lt;/p&gt;

&lt;p&gt;然后12月末的时候，和以前实验室的童鞋去了惠东玩了两天一夜。不用花钱哦~好把，是别人团购多出来的位置，让我占便宜了。哈哈~感觉惠东的海好漂亮哦。那个双月湾真的很不错哦。不过其他地方就一般般了。去的第二天好像是妈祖出海庆典，好像是60年一次。好把，远远眺望了几眼就走了~&lt;/p&gt;

&lt;p&gt;这一年，基本没看什么书（惭愧，摔摔摔）。
下面是看过的(我都有实体书)：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;活法 稻盛和夫&lt;/li&gt;
  &lt;li&gt;因为疼痛所以叫青春&lt;/li&gt;
  &lt;li&gt;1988我想和这个世界谈谈&lt;/li&gt;
  &lt;li&gt;这些道理没人告诉你&lt;/li&gt;
  &lt;li&gt;浪潮之巅&lt;/li&gt;
  &lt;li&gt;形式感 网页视觉设计创意拓展与快速表现&lt;/li&gt;
  &lt;li&gt;设计师要懂心理学&lt;/li&gt;
  &lt;li&gt;超越平凡的平面设计 版式设计原理与应用&lt;/li&gt;
  &lt;li&gt;Nodejs开发指南&lt;/li&gt;
  &lt;li&gt;深入浅出Nodejs&lt;/li&gt;
  &lt;li&gt;MongoDB权威指南&lt;/li&gt;
  &lt;li&gt;javascript编程精解&lt;/li&gt;
  &lt;li&gt;精彩绝伦的css&lt;/li&gt;
  &lt;li&gt;HTML5程序设计&lt;/li&gt;
  &lt;li&gt;疯狂Android讲义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他还有一些就忘记了，借图书馆的书，还了就忘记了（这记忆力，是病，得治）。上面这些也很多忘记了。想想都好惭愧，一年这么久居然就看这么几本书~&lt;/p&gt;

&lt;p&gt;当然，还看了好多好多无聊的小说，上课无聊嘛，总要消磨时间（是不是暴露什么了）。&lt;/p&gt;

&lt;p&gt;总的来说，2014，挺好。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>java的urlrewritefilter简单使用</title>
   <link href="jeffdeng.me/java/2014/12/12/java-urlrewritefilter"/>
   <updated>2014-12-12T00:00:00+08:00</updated>
   <id>jeffdeng.me/java/2014/12/12/java-urlrewritefilter</id>
   <content type="html">
&lt;p&gt;由于项目中只用了&lt;code&gt;tomcat&lt;/code&gt;，没有用&lt;code&gt;Apache&lt;/code&gt;，然后想做&lt;code&gt;www&lt;/code&gt;重定向。就如让所有访问&lt;code&gt;baidu.com&lt;/code&gt;都301永久重定向到&lt;code&gt;www.baidu.com&lt;/code&gt;。然后时间紧急，对&lt;code&gt;Apache&lt;/code&gt;不是很熟悉（懒的去配置），就直接用了&lt;code&gt;java&lt;/code&gt;的一个包：
&lt;code&gt;urlrewritefilter&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;官网是：&lt;a href=&quot;http://tuckey.org/urlrewrite/&quot;&gt;http://tuckey.org/urlrewrite/&lt;/a&gt;。使用方法也很简单，这里简单说下。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1.下载&lt;/h3&gt;
&lt;p&gt;先去下载&lt;code&gt;urlrewritefilter-x.x.x.jar &lt;/code&gt;包。下载好放到&lt;code&gt;WEB-INF/lib&lt;/code&gt;目录下。&lt;/p&gt;

&lt;h3 id=&quot;webxml&quot;&gt;2.配置web.xml&lt;/h3&gt;
&lt;p&gt;修改web.xml，把下面代码放到所有servlet mappings的前面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;UrlRewriteFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.tuckey.web.filters.urlrewrite.UrlRewriteFilter&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;UrlRewriteFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;dispatcher&amp;gt;REQUEST&amp;lt;/dispatcher&amp;gt;
    &amp;lt;dispatcher&amp;gt;FORWARD&amp;lt;/dispatcher&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是对应的参数文档 &lt;a href=&quot;http://urlrewritefilter.googlecode.com/svn/trunk/src/doc/manual/4.0/index.html#filterparams&quot;&gt;filterparams&lt;/a&gt;。这就配置完了（这里有个很坑爹的问题，待会说）。&lt;/p&gt;

&lt;h3 id=&quot;urlrewritexml&quot;&gt;3.增加 &lt;code&gt;urlrewrite.xml&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;然后在 &lt;code&gt;WEB-INF&lt;/code&gt; 文件夹里增加多 &lt;code&gt;urlrewrite.xml&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;下面是官方标准urlrewrite.xml文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE urlrewrite PUBLIC &quot;-//tuckey.org//DTD UrlRewrite 4.0//EN&quot;
        &quot;http://www.tuckey.org/res/dtds/urlrewrite4.0.dtd&quot;&amp;gt;

&amp;lt;!--

    Configuration file for UrlRewriteFilter
    http://www.tuckey.org/urlrewrite/

--&amp;gt;
&amp;lt;urlrewrite&amp;gt;

    &amp;lt;rule&amp;gt;
        &amp;lt;note&amp;gt;
            The rule means that requests to /test/status/ will be redirected to /rewrite-status
            the url will be rewritten.
        &amp;lt;/note&amp;gt;
        &amp;lt;from&amp;gt;/test/status/&amp;lt;/from&amp;gt;
        &amp;lt;to type=&quot;redirect&quot;&amp;gt;%{context-path}/rewrite-status&amp;lt;/to&amp;gt;
    &amp;lt;/rule&amp;gt;


    &amp;lt;outbound-rule&amp;gt;
        &amp;lt;note&amp;gt;
            The outbound-rule specifies that when response.encodeURL is called (if you are using JSTL c:url)
            the url /rewrite-status will be rewritten to /test/status/.

            The above rule and this outbound-rule means that end users should never see the
            url /rewrite-status only /test/status/ both in thier location bar and in hyperlinks
            in your pages.
        &amp;lt;/note&amp;gt;
        &amp;lt;from&amp;gt;/rewrite-status&amp;lt;/from&amp;gt;
        &amp;lt;to&amp;gt;/test/status/&amp;lt;/to&amp;gt;
    &amp;lt;/outbound-rule&amp;gt;


    &amp;lt;!--

    INSTALLATION

        in your web.xml add...

        &amp;lt;filter&amp;gt;
            &amp;lt;filter-name&amp;gt;UrlRewriteFilter&amp;lt;/filter-name&amp;gt;
            &amp;lt;filter-class&amp;gt;org.tuckey.web.filters.urlrewrite.UrlRewriteFilter&amp;lt;/filter-class&amp;gt;
            &amp;lt;init-param&amp;gt;
                &amp;lt;param-name&amp;gt;logLevel&amp;lt;/param-name&amp;gt;
                &amp;lt;param-value&amp;gt;WARN&amp;lt;/param-value&amp;gt;
            &amp;lt;/init-param&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;filter-mapping&amp;gt;
            &amp;lt;filter-name&amp;gt;UrlRewriteFilter&amp;lt;/filter-name&amp;gt;
            &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
        &amp;lt;/filter-mapping&amp;gt;

     EXAMPLES

     Redirect one url
        &amp;lt;rule&amp;gt;
            &amp;lt;from&amp;gt;/some/old/page.html&amp;lt;/from&amp;gt;
            &amp;lt;to type=&quot;redirect&quot;&amp;gt;/very/new/page.html&amp;lt;/to&amp;gt;
        &amp;lt;/rule&amp;gt;

    Redirect a directory
        &amp;lt;rule&amp;gt;
            &amp;lt;from&amp;gt;/some/olddir/(.*)&amp;lt;/from&amp;gt;
            &amp;lt;to type=&quot;redirect&quot;&amp;gt;/very/newdir/$1&amp;lt;/to&amp;gt;
        &amp;lt;/rule&amp;gt;

    Clean a url
        &amp;lt;rule&amp;gt;
            &amp;lt;from&amp;gt;/products/([0-9]+)&amp;lt;/from&amp;gt;
            &amp;lt;to&amp;gt;/products/index.jsp?product_id=$1&amp;lt;/to&amp;gt;
        &amp;lt;/rule&amp;gt;
    eg, /products/1234 will be passed on to /products/index.jsp?product_id=1234 without the user noticing.

    Browser detection
        &amp;lt;rule&amp;gt;
            &amp;lt;condition name=&quot;user-agent&quot;&amp;gt;Mozilla/[1-4]&amp;lt;/condition&amp;gt;
            &amp;lt;from&amp;gt;/some/page.html&amp;lt;/from&amp;gt;
            &amp;lt;to&amp;gt;/some/page-for-old-browsers.html&amp;lt;/to&amp;gt;
        &amp;lt;/rule&amp;gt;
    eg, will pass the request for /some/page.html on to /some/page-for-old-browsers.html only for older
    browsers whose user agent srtings match Mozilla/1, Mozilla/2, Mozilla/3 or Mozilla/4.

    Centralised browser detection
        &amp;lt;rule&amp;gt;
            &amp;lt;condition name=&quot;user-agent&quot;&amp;gt;Mozilla/[1-4]&amp;lt;/condition&amp;gt;
            &amp;lt;set type=&quot;request&quot; name=&quot;browser&quot;&amp;gt;moz&amp;lt;/set&amp;gt;
        &amp;lt;/rule&amp;gt;
    eg, all requests will be checked against the condition and if matched
    request.setAttribute(&quot;browser&quot;, &quot;moz&quot;) will be called.

    --&amp;gt;

&amp;lt;/urlrewrite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们经常用到的就两个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //重定向 地址栏显示的是实际地址
    &amp;lt;rule&amp;gt;
        &amp;lt;from&amp;gt;/some/olddir/(.*)&amp;lt;/from&amp;gt;
        &amp;lt;to type=&quot;redirect&quot;&amp;gt;/very/newdir/$1&amp;lt;/to&amp;gt;
    &amp;lt;/rule&amp;gt;

//转发 地址了显示的是虚拟地址
    &amp;lt;rule&amp;gt;
        &amp;lt;from&amp;gt;/products/([0-9]+)&amp;lt;/from&amp;gt;
        &amp;lt;to&amp;gt;/products/index.jsp?product_id=$1&amp;lt;/to&amp;gt;
    &amp;lt;/rule&amp;gt;
eg, /products/1234 will be passed on to /products/index.jsp?product_id=1234 without the user noticing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配的是java的正则表达式。&lt;/p&gt;

&lt;h3 id=&quot;www301&quot;&gt;4.www301重定向&lt;/h3&gt;
&lt;p&gt;下面就是我要用到的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//如果地址的域名不是 www.baidu.com 就会跳转到www.baidu.com
//为了考虑开发情况，把 localhost 也加到里面
&amp;lt;rule&amp;gt;
    &amp;lt;name&amp;gt;seo redirect&amp;lt;/name&amp;gt;
    &amp;lt;condition name=&quot;host&quot; operator=&quot;notequal&quot;&amp;gt;^www.baidu.com&amp;lt;/condition&amp;gt;
    &amp;lt;condition name=&quot;host&quot; operator=&quot;notequal&quot;&amp;gt;^localhost&amp;lt;/condition&amp;gt;
    &amp;lt;from&amp;gt;^/(.*)&amp;lt;/from&amp;gt;
    &amp;lt;to type=&quot;permanent-redirect&quot; last=&quot;true&quot;&amp;gt;http://www.baidu.com/$1&amp;lt;/to&amp;gt;
&amp;lt;/rule&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里为止，一切都正常。但是我用转发却不行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;rule&amp;gt;
    &amp;lt;from&amp;gt;/products/([0-9]+)&amp;lt;/from&amp;gt;
    &amp;lt;to&amp;gt;/products/index.jsp?product_id=$1&amp;lt;/to&amp;gt;
&amp;lt;/rule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问&lt;code&gt;localhost:8080/products/123&lt;/code&gt;一直报&lt;code&gt;404&lt;/code&gt;，而且还是乱码。&lt;/p&gt;

&lt;p&gt;这个问题纠结了好久。&lt;code&gt;api&lt;/code&gt;里也没看到哪里出问题了。最后，终于发现，是转发后被&lt;code&gt;struts&lt;/code&gt;拦截了。所以，要修改&lt;code&gt;web.xml&lt;/code&gt;。在&lt;code&gt;struts2&lt;/code&gt;的&lt;code&gt;&amp;lt;filter-mapping&amp;gt;&lt;/code&gt;里加上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dispatcher&amp;gt;REQUEST&amp;lt;/dispatcher&amp;gt;  
&amp;lt;dispatcher&amp;gt;FORWARD&amp;lt;/dispatcher&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以了。浪费好多时间去弄这个问题，囧~&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://xlaohe1.iteye.com/blog/1130854&quot;&gt;http://xlaohe1.iteye.com/blog/1130854&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://fanzhongyun.iteye.com/blog/1221170&quot;&gt;http://fanzhongyun.iteye.com/blog/1221170&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/ygf215/article/details/4766285&quot;&gt;http://blog.csdn.net/ygf215/article/details/4766285&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nematodes.org/martin/2010/02/04/301-permanent-redirect-with-tomcat-howto/&quot;&gt;http://nematodes.org/martin/2010/02/04/301-permanent-redirect-with-tomcat-howto/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>译.css选择器渲染优化</title>
   <link href="jeffdeng.me/css/2014/12/08/css-selector"/>
   <updated>2014-12-08T00:00:00+08:00</updated>
   <id>jeffdeng.me/css/2014/12/08/css-selector</id>
   <content type="html">
&lt;p&gt;原文：&lt;a href=&quot;http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/&quot;&gt;css selector performance has changed&lt;/a&gt;。这里来看看这篇文章的主要内容。&lt;/p&gt;

&lt;p&gt;下面是我们之前就知道的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;选择器匹配元素是从右到左，应该避免比较艰难匹配的选择器。&lt;/li&gt;
  &lt;li&gt;后代选择器是比较缓慢的，尤其是最右的选择器匹配到大量元素的时候。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改变的现状：&lt;/p&gt;

&lt;p&gt;Antti Koivisto，是&lt;code&gt;WebKit&lt;/code&gt;代码的贡献者，最近花了一些时间去优化&lt;code&gt;css&lt;/code&gt;的选择器匹配。在完成这项工作后，他说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我的观点是：写代码的人不应该去担心选择器的优化，这应该是浏览器引擎的工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面我们来看看他在四个方面做的特别优化：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Style Sharing（共享样式）&lt;/li&gt;
  &lt;li&gt;Rule Hashes（哈希规则）&lt;/li&gt;
  &lt;li&gt;Ancestor Filters（父代过滤器）&lt;/li&gt;
  &lt;li&gt;Fast Path（快速路径）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;共享样式&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;共享样式允许浏览器根据已经匹配到得元素，快速找出其他相同样式的元素。&lt;/p&gt;

&lt;p&gt;ex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
  &amp;lt;p&amp;gt;foo&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;bar&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果浏览器引擎已经计算出第一个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;的样式（已经渲染），它就不用再去计算第二个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;的样式，直接渲染就是了（当然这个前提是第一个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;和第二个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;的样式选择器一致，如&lt;code&gt;div p{}
&lt;/code&gt;之类）。这是很简单的一小步，却优化
选择器的一大步。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;哈希规则&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们现在都知道匹配选择器是从右到左，所以最右边的选择器是很重要的。哈希规则基于最右的选择器来把选择器分组。举个例子，下面的选择器会分成三组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a {}
div p {}
div p.legal {}
#sidebar a {}
#sidebar p {}

1: a, a {}, #sidebar a

2: p, div p {}, #sidebar p {}

3: p.legal , div p.legal {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当浏览器使用哈希规则的时候，它不一定要去查找样式表中所个有的单的选择器，而是分组去匹配。
这对于页面上单个的&lt;code&gt;HTML&lt;/code&gt;元素，同样很巧妙的节省了很多工作。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;父代过滤器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;父代过滤器是有点复杂的。它们通过计算一个选择器可以匹配的可能性，去过滤，所以也称为可能性过滤器。所以，父代过滤器可以快速排除那些没有匹配的元素。它通过&lt;code&gt;class&lt;/code&gt;,&lt;code&gt;id&lt;/code&gt;,&lt;code&gt;tag&lt;/code&gt;去匹配后代和子选择器。后代选择器是认为匹配比较慢的，因为渲染引擎要循环所有的父节点，尝试选择器是否匹配。这个时候&lt;code&gt;bloom&lt;/code&gt;过滤器就闪亮登场了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bloom&lt;/code&gt;过滤器是一个数据集合，可以让你判断某个选择器是否在集合中.bloom过滤器判断一个
css规则是否是在当前的元素集合中（The bloom filter tests whether a CSS rule is a member of the set of rules which match the element you are currently testing）。这其中很特别的一件事是，误报是有可能的，但漏报是不可能的。这意味着，如果bloom过滤器判断出一个选择器不符合当前的元素，浏览器就会停止查看当前的选择器，跳到下一个选择器。这里又节省了很多时间。如果&lt;code&gt;bloom&lt;/code&gt;过滤器判断出当前的元素匹配，浏览器会继续通过常规的方法去进行100%的准确匹配。样式表文件越大，误报的几率就越大。所以要保持样式表文件的比较近小。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;&lt;strong&gt;快速路径&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;快速路径通过内在的循环，而不是递归，去取代常规的匹配逻辑（Fast path re-implements more general matching logic using a non-recursive, fully inlined loop. ）。 它通常用在匹配下面组合的选择器：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;后代，子代，子代选择器组合&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;tag&lt;/code&gt;，&lt;code&gt;id&lt;/code&gt;，&lt;code&gt;class&lt;/code&gt;和属性组合选择器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上就是Antti对&lt;code&gt;WebKit&lt;/code&gt;引擎的四个优化。(有点高深，不是很懂~囧)&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>译.css性能</title>
   <link href="jeffdeng.me/css/2014/12/08/css-performance"/>
   <updated>2014-12-08T00:00:00+08:00</updated>
   <id>jeffdeng.me/css/2014/12/08/css-performance</id>
   <content type="html">
&lt;p&gt;原文：&lt;a href=&quot;https://dl.dropboxusercontent.com/u/39519/talks/cssperf/index.html&quot;&gt;CSS Performance&lt;/a&gt;（2011年文章，有着很赞的翻转效果，前提是祭出高级浏览器）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Reflows（重排）&lt;/li&gt;
  &lt;li&gt;Hardware Accelerated Css（硬件加速css）&lt;/li&gt;
  &lt;li&gt;Avoiding Expensive Css（避免高消耗css）&lt;/li&gt;
  &lt;li&gt;Selector Perf（选择器性能）&lt;/li&gt;
  &lt;li&gt;Style Matching Perf（样式匹配性能）&lt;/li&gt;
  &lt;li&gt;Polyfills&lt;/li&gt;
  &lt;li&gt;Debugging（调试）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;&lt;strong&gt;1. 重排&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;先来看看html页面的渲染、绘制流程图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2014/css_performance/render.png&quot; alt=&quot;render&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据&lt;code&gt;Html&lt;/code&gt;标签生成&lt;code&gt;Dom&lt;/code&gt;树（&lt;code&gt;Dom tree&lt;/code&gt;）；根据默认的，用户自定义的样式生成样式结构（&lt;code&gt;Styles struct&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;生成渲染树（&lt;code&gt;Render tree&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;绘制页面&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面是重排的渲染短视频：&lt;/p&gt;

&lt;video controls=&quot;&quot; preload=&quot;&quot; autobuffer=&quot;&quot; width=&quot;860&quot; height=&quot;510&quot;&gt;
	&lt;source src=&quot;https://dl.dropboxusercontent.com/u/39519/talks/cssperf/assets/geckoreflow-mozillaorg.mp4&quot; type=&quot;video/mp4&quot; /&gt;
	&lt;source src=&quot;https://dl.dropboxusercontent.com/u/39519/talks/cssperf/assets/geckoreflow-mozillaorg.webm&quot; type=&quot;video/webm&quot; /&gt;
&lt;/video&gt;

&lt;p&gt;下面，先看看重绘机制：如何（不）触发&lt;code&gt;WebKit&lt;/code&gt;的布局（&lt;a href=&quot;http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html&quot;&gt;How (not) to trigger a layout in WebKit&lt;/a&gt;）（2011）。&lt;/p&gt;

&lt;p&gt;简单译文：&lt;/p&gt;

&lt;p&gt;许多&lt;code&gt;Web&lt;/code&gt;开发者意识到，一段&lt;code&gt;js&lt;/code&gt;脚本在运行的时候，是在触发&lt;code&gt;DOM&lt;/code&gt;的操作而不是执行代码本身。这样一个潜在消耗时间，从&lt;code&gt;Dom&lt;/code&gt;树构建渲染树（&lt;code&gt;Render tree&lt;/code&gt;）的过程，被称作布局（又称重排）。约庞大越复杂的&lt;code&gt;Dom&lt;/code&gt;树，就会消耗更多的时间。&lt;/p&gt;

&lt;p&gt;一个很重要的方法让页面的不假死，就是让分开的Dom操作放在一起。&lt;/p&gt;

&lt;p&gt;ex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 一般，触发两次布局
var newWidth = aDiv.offsetWidth + 10; // Read
aDiv.style.width = newWidth + &#39;px&#39;; // Write
var newHeight = aDiv.offsetHeight + 10; // Read
aDiv.style.height = newHeight + &#39;px&#39;; // Write

// 更好, 只触发一次布局
var newWidth = aDiv.offsetWidth + 10; // Read
var newHeight = aDiv.offsetHeight + 10; // Read
aDiv.style.width = newWidth + &#39;px&#39;; // Write
aDiv.style.height = newHeight + &#39;px&#39;; // Write
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后这里就会有个问题：什么情况会触发布局？下面是整理的一些元素和方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Element
clientHeight, clientLeft, clientTop, clientWidth, focus(), getBoundingClientRect(), getClientRects(), innerText, offsetHeight, offsetLeft, offsetParent, offsetTop, offsetWidth, outerText, scrollByLines(), scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(), scrollLeft, scrollTop, scrollWidth

Frame, Image
height, width

Range
getBoundingClientRect(), getClientRects()

SVGLocatable
computeCTM(), getBBox()

SVGTextContent
getCharNumAtPosition(), getComputedTextLength(), getEndPositionOfChar(), getExtentOfChar(), getNumberOfChars(), getRotationOfChar(), getStartPositionOfChar(), getSubStringLength(), selectSubString()

SVGUse
instanceRoot

window
getComputedStyle(), scrollBy(), scrollTo(), scrollX, scrollY, webkitConvertPointFromNodeToPage(), webkitConvertPointFromPageToNode()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然列出的这些不是全部，这只是一个很好的开始。最好的方法是通过Chrome或者Firefox浏览器的调试器去查看。（翻译完）&lt;/p&gt;

&lt;p&gt;好的，再回到这里，我们看看什么动作会触发重排。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;增加，删除，更新&lt;code&gt;Dom&lt;/code&gt;节点。&lt;/li&gt;
  &lt;li&gt;通过&lt;code&gt;display:none&lt;/code&gt;隐藏元素。&lt;/li&gt;
  &lt;li&gt;对页面上的&lt;code&gt;Dom&lt;/code&gt;元素进行移动等动画。&lt;/li&gt;
  &lt;li&gt;增加样式，或调整样式属性。&lt;/li&gt;
  &lt;li&gt;用户改变窗口大小，改变字体大小，或者滚动页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;策略：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在触发重排动作前，对&lt;code&gt;Dom&lt;/code&gt;进行批量操作。&lt;/li&gt;
  &lt;li&gt;复制节点的属性，在复制的节点里进行操作，在一次交换过来。&lt;/li&gt;
  &lt;li&gt;先用&lt;code&gt;display:none&lt;/code&gt;隐藏节点，再进行大量的操作，再通过&lt;code&gt;display&lt;/code&gt;显示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多重排文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/&quot;&gt;Stoyan Stefanov on Reflow/Repaint&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://calendar.perfplanet.com/2009/the-new-game-show-will-it-reflow/&quot;&gt;The new game show: “Will it reflow?”&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.browserscope.org/?category=reflow&quot;&gt;Mozilla’s David Baron on Browser Internals for Web Developers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=a2_6bGNZ7bA&quot;&gt;WebKit blog five-part series on rendering&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;css&quot;&gt;&lt;strong&gt;2.硬件加速css&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;充分利用&lt;code&gt;Css&lt;/code&gt;的&lt;code&gt;transitions&lt;/code&gt;和&lt;code&gt;transforms&lt;/code&gt;达到最优的质量。
这方面主要应用于手机，ios和Android&lt;/p&gt;

&lt;video controls=&quot;&quot; preload=&quot;&quot; autobuffer=&quot;&quot; width=&quot;860&quot; height=&quot;310&quot;&gt;
	&lt;source src=&quot;https://dl.dropboxusercontent.com/u/39519/talks/cssperf/assets/translate3d.mp4&quot; type=&quot;video/mp4&quot; /&gt;
	&lt;source src=&quot;https://dl.dropboxusercontent.com/u/39519/talks/cssperf/assets/translate3d.webm&quot; type=&quot;video/webm&quot; /&gt;
&lt;/video&gt;

&lt;h2 id=&quot;css-1&quot;&gt;&lt;strong&gt;3.避免高消耗css&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;@font-face&lt;/li&gt;
  &lt;li&gt;box-shadow&lt;/li&gt;
  &lt;li&gt;opacity compositing&lt;/li&gt;
  &lt;li&gt;gradients&lt;/li&gt;
  &lt;li&gt;text-align&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(这部分待续…)&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;&lt;strong&gt;4.选择器性能&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;浏览器默认是从右到左。&lt;/p&gt;

&lt;p&gt;下面选择器引擎是从左到右：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mootools&lt;/li&gt;
  &lt;li&gt;Sly&lt;/li&gt;
  &lt;li&gt;Peppy&lt;/li&gt;
  &lt;li&gt;Dojo Acme&lt;/li&gt;
  &lt;li&gt;Ext JS&lt;/li&gt;
  &lt;li&gt;Prototype.js&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是从右到左：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sizzle&lt;/li&gt;
  &lt;li&gt;YUI 3&lt;/li&gt;
  &lt;li&gt;NWMatcher&lt;/li&gt;
  &lt;li&gt;querySelectorAll&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择器优化&lt;/p&gt;

&lt;p&gt;推荐组合是：&lt;code&gt;tag .class&lt;/code&gt;，让标签在左边，尽可能让class在右边。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;&lt;strong&gt;5.样式匹配性能&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;关于样式匹配，请看&lt;a href=&quot;http://screwlewse.com/2010/08/different-css-techniques-and-their-performance/&quot;&gt;样式匹配性能&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;polyfills&quot;&gt;&lt;strong&gt;6.Polyfills&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;关于Polyfills的介绍：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Polyfilling 是由 RemySharp 提出的一个术语，它是用来描述复制缺少的 API 和API 功能的行为。你可以使用它编写单独应用的代码而不用担心其他浏览器原生是不是支持。实际上，polyfills并不是新技术也不是和 HTML5 捆绑到一起的。我们已经在如json2.js，ie7-js 和为 IE 浏览器提供透明 PNG支持的JS中使用过了。而和现在 polyfills 的区别就是去年增加的 HTML5 polyfills。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相关信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://selectivizr.com/&quot;&gt;Selectivizr&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://css3pie.com/&quot;&gt;CSS3Pie&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills&quot;&gt;Modernizr wiki list of polyfills&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;&lt;strong&gt;7.调试&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;主要是手机硬件方面的调试。
相关信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://peter.sh/experiments/chromium-command-line-switches/&quot;&gt;All of Chrome’s command line switches&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mir.aculo.us/2011/02/08/visualizing-webkits-hardware-acceleration/&quot;&gt;Thomas Fuchs: Safari and iPhone Simulator CoreAnimation debugging info.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/html5/&quot;&gt;HTML5Rocks: Improving the Performance of your HTML5 App&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>译.层叠和选择器的明确度--权重</title>
   <link href="jeffdeng.me/css/2014/12/05/css-specificity-wars"/>
   <updated>2014-12-05T00:00:00+08:00</updated>
   <id>jeffdeng.me/css/2014/12/05/css-specificity-wars</id>
   <content type="html">
&lt;p&gt;这是2005年的文章，内容已经比较老，看看就好。&lt;/p&gt;

&lt;p&gt;在css编码规范中提到：&lt;a href=&quot;http://www.stuffandnonsense.co.uk/archives/css_specificity_wars.html&quot;&gt;层叠和选择器的明确度&lt;/a&gt;，翻译了一下主要的内容，不过建议还是去看原版。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于原作者
Andy Clarke，是一个英国的的设计师，作者，同时是在设计，css和web accessibility方面具有很大热情的演说家。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;整篇文章主要说权重的问题，下面是大家对权重的常规理解：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;id&lt;/code&gt;选择器的权重是 100&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;class&lt;/code&gt;选择器的权重是 10&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTML&lt;/code&gt;选择器的权重为 1&lt;/li&gt;
  &lt;li&gt;选择器的权重就是对应数字加起来&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后下面是W3C对权重的解析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;计算选择器中的&lt;code&gt;id&lt;/code&gt;数量（=a）&lt;/li&gt;
  &lt;li&gt;计算选择器中属性和&lt;code&gt;class&lt;/code&gt;的数量（=b）&lt;/li&gt;
  &lt;li&gt;计算选择器中元素的数量（=c）&lt;/li&gt;
  &lt;li&gt;然后把这些数字按a-b-c连起来，abc就是这个选择器的权重&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后下面是作者的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;元素选择器权重 0，0，1&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;class&lt;/code&gt;选择器权重 0，1，0&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;id&lt;/code&gt;选择器权重 1，0，0&lt;/li&gt;
  &lt;li&gt;然后把对应选择器的数字按对应的位置加起来就是权重&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;感觉3种方法都差不多，只要能正确判断，哪一种都可以。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>express的诡异错误</title>
   <link href="jeffdeng.me/nodejs/2014/12/03/express-fail"/>
   <updated>2014-12-03T00:00:00+08:00</updated>
   <id>jeffdeng.me/nodejs/2014/12/03/express-fail</id>
   <content type="html">
&lt;p&gt;最近用 &lt;code&gt;express&lt;/code&gt; 新建项目，发现一个很诡异的问题，出现的简直毫无理由。我的exprss 版本是&lt;code&gt;4.9.0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;先看 &lt;code&gt;express&lt;/code&gt; 的参数使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;express -h

Usage: express [options] [dir]

Options:

-h, --help          output usage information
-V, --version       output the version number
-e, --ejs           add ejs engine support (defaults to jade)
    --hbs           add handlebars engine support
-H, --hogan         add hogan.js engine support
-c, --css &amp;lt;engine&amp;gt;  add stylesheet &amp;lt;engine&amp;gt; support (less|stylus|compass) (defaults to plain css)
-f, --force         force on non-empty directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建项目，用 &lt;code&gt;ejs&lt;/code&gt; 和 &lt;code&gt;sass&lt;/code&gt; 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;express -e -c compass test

create : test
create : test/package.json
create : test/app.js
create : test/public
create : test/public/javascripts
create : test/public/images
create : test/public/stylesheets
create : test/public/stylesheets/style.scss
create : test/routes
create : test/routes/index.js
create : test/routes/users.js
create : test/views
create : test/views/index.ejs
create : test/views/error.ejs
create : test/bin
create : test/bin/www

install dependencies:
  $ cd test &amp;amp;&amp;amp; npm install

run the app:
  $ DEBUG=test ./bin/www
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;npm install&lt;/code&gt; 后，执行 &lt;code&gt;DEBUG=test ./bin/www&lt;/code&gt; ,现在还是ok的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; test Express server listening on port 3000 +0ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用浏览器打开 &lt;code&gt;http://localhost:3000/&lt;/code&gt;, 问题来了：&lt;/p&gt;

&lt;p&gt;首先是浏览器报错：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2014/express_fail/20141203-1.png&quot; alt=&quot;chrome-err&quot; /&gt;&lt;/p&gt;

&lt;p&gt;错误信息是：&lt;code&gt;(failed) net::ERR_CONNECTION_REFUSED&lt;/code&gt; ，其实应该报404错误，因为没有这个样式文件。然后这个时候，控制台也会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  test Express server listening on port 3000 +0ms
GET / 200 77.090 ms - 207

events.js:72
        throw er; // Unhandled &#39;error&#39; event
              ^
Error: spawn ENOENT
    at errnoException (child_process.js:1001:11)
    at Process.ChildProcess._handle.onexit (child_process.js:792:34)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键是我只是初始化了项目，代码完全没有改过。&lt;/p&gt;

&lt;p&gt;其实问题出在 &lt;code&gt;node-compass&lt;/code&gt; 模块,可以查看github上的用法说明 &lt;a href=&quot;https://github.com/nathggns/node-compass&quot;&gt;node-compass&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;node-compass requires the compass ruby gem in order to compile compass.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先你的项目要安装ruby， 然后安装 compass。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem update --system
$ gem install compass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧，其实是小问题，只是没想通。囧~&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>2014年目标，计划</title>
   <link href="jeffdeng.me/%E7%94%9F%E6%B4%BB/2014/02/20/plan"/>
   <updated>2014-02-20T00:00:00+08:00</updated>
   <id>jeffdeng.me/%E7%94%9F%E6%B4%BB/2014/02/20/plan</id>
   <content type="html">
&lt;blockquote&gt;
  &lt;p&gt;注：原文发布于豆瓣上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前言：之前文章一直发在技术blog，不过最近非技术文章比较多，发了几篇觉得发不下去了。所以就来了豆瓣。都是生活中琐碎的事，看了就忘了吧。&lt;/p&gt;

&lt;p&gt;原来一个人的目标真的会随着时间的推进而改变，而且周期还是，如此快。&lt;/p&gt;

&lt;p&gt;新年时，我的愿望是，或者目标是：换mx3，买kindle，买台1500左右的山地车，买台mac pro，去海南环岛。我不知道怎样的才算是愿望，或者是一瞬间的想法，又或者是蓄谋已久的意向。上面这些应该都是一瞬间的吧，因为在这一瞬间，对上面那些的欲望，说真的，不是很强。&lt;/p&gt;

&lt;p&gt;好吧，那新的愿望或者计划是什么呢。&lt;/p&gt;

&lt;p&gt;让我先酝酿下。好像，我一生还没有奋斗过，为着某个目标。高一时英语课听写单词，每组一个代表，而我，就是我们组的代表。原谅我那惨不忍睹的记忆力，我一个都没写出来，导致最直接的结果是，我们组输了。恩，然后全组人一起唱了首歌。下课后，同桌A在那里抱怨，你怎么这么差劲！搞的我们组输了，还要被罚唱歌。哦，原来我和A同桌过，如果不是因为这件事我还不记得呢。然后我沉默不语。这时坐我前面的语代，一个很萝莉的女生为我打抱不平说，其实我也很努力了，不要怪他。有句话说的很对，自己的情况自己最清楚。我当时是懒得记单词，所以才一个都没写出来。有人为我打抱不平真的让我羞愧不已。然后暗自下决心，我一定要认真学好英语！事实证明，我第二天又恢复原样了。因为，我睡了一觉。一般我睡了一觉很多东西都选择性遗忘。&lt;/p&gt;

&lt;p&gt;高三时，补课，上化学课。当时代课老师是号称学校四大恶人之一的阿蔡。当然，之前我并没有上过他的课。我对他的所有印象都来源于同学。某天自习课，他路过教室，看到窗边一同学玩手机，一把拉开窗跳讲去把手机抢了，还把那同学臭骂一顿。还有把女同学骂哭是经常的事。所有当时我上他的课都小心翼翼的。刚好那一周我坐第一排，然后他就点了我上去做题目，好像是划分物质的类别。当时我就蒙了，上去乱写一通。然后他讲评的时候，就在重复一句话，“又错了！”“又错了！”当时我觉得这也算是一场耻辱吧，学生时代的耻辱！然后我发奋，我一定会学会化学的！然后第二天，又打回原样了。因为，我睡了一觉~&lt;/p&gt;

&lt;p&gt;还有就是高三寒假，我背了好多书回去，想着最后一个寒假了，要好好努力。结果，你知道的，不断的睡觉……&lt;/p&gt;

&lt;p&gt;恩，扯了这么多无关紧要的事。就是想说明一个问题，对于我很严重的问题：我真的没有为什么奋斗过。某天晚上睡觉的时候，在想，如果明天是最后一天，我最后悔的是什么。当时想的是，啊，原来自己都没有奋斗过。这算是人生的一大遗憾吧。&lt;/p&gt;

&lt;p&gt;恩，这算是这段时间的一个目标。因为大三下学期，很多东西，不努力就要难过了。&lt;/p&gt;

&lt;p&gt;努力什么呢。吃饭？睡觉？恩，这是一点。吃好饭睡好觉才有饱满的精神去奋斗。虽然不知道将来的定位，但什么都学点吧。毕竟是有兴趣。技术这些东西，时刻都有新的，应该不会无聊吧。老爸老妈说公务员好，去考！但我是很讨厌公务员的生活啊。没办法，至少现在的我是这样想的。&lt;/p&gt;

&lt;p&gt;恩，学多点东西，锻炼身体。三月份有个百公里，虽然基友一直不建议我去，但还是想尝试下。毕竟，很多东西不去尝试，那根本不知道怎么回事。&lt;/p&gt;

&lt;p&gt;恩，扯远了。&lt;/p&gt;

&lt;p&gt;之前的我，考虑问题更多的是在考虑自己。突然想到父母老了啊，自己好像很少从父母的角度思考。我这样的年纪，父母肯定是担心我找不到好工作吧。以前说奋斗，说努力，总是睡一觉就过去了。之前总是认为如果某件事刺激我，那我肯定会奋发的。现在想着，最好没有这样的事情。努力无论什么时候都是自己的事，外物只是有时候有点推动作用而已。努力学好想学的东西然后找到好工作。&lt;/p&gt;

&lt;p&gt;恩，挺好的。努力吧。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>2013象征性总结</title>
   <link href="jeffdeng.me/%E7%94%9F%E6%B4%BB/2014/01/01/2013-summary"/>
   <updated>2014-01-01T00:00:00+08:00</updated>
   <id>jeffdeng.me/%E7%94%9F%E6%B4%BB/2014/01/01/2013-summary</id>
   <content type="html">
&lt;p&gt;&lt;code&gt;10、9、8、7、6、5、4、3、2、1~happy new year!&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;好吧，其实我是很平淡的宿舍里和几个同样寂寞如雪的基友打牌度过的。一局完了，拿起手机一看，哦！14年了。波澜不惊的感觉–其实是因打牌累的眼睛都转不动了。在goujun破了400大关后，就开心的散场了。然后洗个不算热的热水澡，看了老罗的《我的奋斗》高校演讲视频，玩了盘天天飞车，然后就~~~
早上醒来，原来2014啦，然后想着，总结下自己的2013吧，即使是象征性也好。毕竟有时间又有这样的心情。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;一、学习&lt;/h4&gt;

&lt;p&gt;2013年，感觉没学到什么。&lt;/p&gt;

&lt;p&gt;因为在学校兼职写写简单的前端，所以年30的前三天才回家，初六又很匆忙的赶上来。真的很讨厌坐夜车，黑呼呼的一片，睡不着就不知道干什么了，大家都在睡觉。每次要来学校，总是会有一些悲壮的感受，觉得自己这学期一定要好好学习了，之前的时间都浪费了。但，也只是三分钟热情的事。&lt;/p&gt;

&lt;p&gt;然后还是上课玩手机，下课跑去代码，作业抄抄，报告写写。休闲的过着小生活。等到考试了才发现，啊，原来要考试了，还没看书啊。然后向大师兄申请了两周复习时间，不用去代码。因为之前挂了不少科，大师兄豪爽的答应了。&lt;/p&gt;

&lt;p&gt;那接下来应该是惨无人道、暗无天日的复习时间了吧！没有。很开心的看完了nikita的第一季，然后看了一本小说，具体名字忘了，反正就是浪费时间看的。每天都睡到11点，吃个饭回来再看电视剧，真的是一个学期里最舒服的日子了，当时一直这样想。&lt;/p&gt;

&lt;p&gt;等到考试了，才急急忙忙看看书。基本上是一个上午或一个下午看一科。果然，全都是低空飘过。概率论还挂了–没办法，内容太多了，只能再来一学期。我对于绩点那些是没什么想法的，不考研，不出国，将来是打算搞IT的啦，如果IT也要很高绩点，那没办法了，搬砖去吧。&lt;/p&gt;

&lt;p&gt;对了，这个学期还考了四级。考完是完全没有想过会过的，想着，没事，反正自己还没努力过。而且当时一个好基友考了两次都没过，所以心理是完全平衡的。谁知道成绩出来后还是低空飘过了。值得一说的是，全是听力拉分的，我想这和我看nikita有一定的原因吧。是不是很奇妙，我看的时候完全没想过对考试有助攻的呢。&lt;/p&gt;

&lt;p&gt;然后暑假回了三天老家，又在广州呆了三天，又跑回来代码了。没办法，人在江湖。因为又挂了一科，当时继续留下来兼职的想法已经没有了。整天就想着怎么和大师兄说我要走。因为之前大师兄的意思是让我做到大四然后转全职的，自己当时也表示可以考虑。不过，自己毕竟还年轻，从大一下学期就兼职，到现在已经差不多一年半了。这个期间，很少或者基本没有参加学校或者班级的活动，整天和一群师兄呆在实验室里代码。这样的环境不能说不好吧，毕竟有一群人一起干活，而且大部分都是老乡，对了，大师兄和我是老乡，所以那个感情还是很舍不得的。&lt;/p&gt;

&lt;p&gt;不过，后来还是决定要走了。因为觉得继续呆下去浪费时间，学习又不搞好，人际又没有，连异性朋友都不多几个。而且，最重要的一点，技术没有进步。&lt;/p&gt;

&lt;p&gt;我不知道其他搞技术的有什么感觉，如果让我连续一年都是做差不多的事，而且都是在前人写好的模板上面写点小小的代码，是不能忍受的。虽然说技术没有大神厉害，但也要让我们有点自己的专属开发吧，而不是什么问题都是让大神写好demo，然后我在复制，粘贴，复制，粘贴……这样的事情我是很讨厌的。也许有人会说，把一件重复的事做好，那也会很牛逼。好吧，这个问题我也想过，但是，如果你忙的只有复制粘贴的时间，你还有什么资格说进步呢。觉得这就和外包公司有点像吧，虽然我没有体验过。基本上就是为了coding而coding，还不够快，再快点，再快点……&lt;/p&gt;

&lt;p&gt;最后，在8月24号晚上，收拾好自己的东西，有点惋惜的离开了实验室。还记得那时候，坐隔壁的师弟很奇怪的看着我的举动，因为我离开的事只是告诉大师兄和其他几个师兄而已。然后提着重重的一袋书走在校道上，很是感慨。&lt;/p&gt;

&lt;p&gt;转眼，大三开始了。还是觉得自己要好好学习，事实再次证明，还是三分钟热度。&lt;/p&gt;

&lt;p&gt;上课去的次数多了，因为换了新校长，抓考勤比较严。真的有点怀念老章的豪放风格。不过还是玩手机，不务正业。有想过好好搞技术的，不过课太多，懒得搞。好吧，都是借口，其实就是懒。然后嘻嘻哈哈到了现在，才发现又要考试了。&lt;/p&gt;

&lt;p&gt;总的来说，这一年基本上是没有进步的。书都没读几本。好像读了《javascript高级程序设计》、《javascript权威指南》、《nodejs开发指南》、《精彩绝伦css》、《深入浅出cofferscript》、《mongdb权威指南》、《禅意花园》、《javascript设计模式》、《基于mvc的javascript》、《javascriptDOM编程艺术》、《疯狂java讲义》、《疯狂android讲义》等等。有的看完，有的没看完，不过现在大部分都忘记了。而且学到的都是比较浅显的知识。其实我更想读读一些文艺性的书籍，别人的传记之类，不过很遗憾，都没有读。因为，懒。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;二、生活&lt;/h4&gt;

&lt;p&gt;生活方面其实是比较平淡的，波澜不惊。&lt;/p&gt;

&lt;p&gt;过完年，有课就去上，没有就去代码。日子过的安稳又无趣，但，这就是生活。基本上，我是不会主动联系别人的。什么意思呢，开心的时候，安静的看看电影，听听音乐。不开心的时候，也看看电影，听听音乐，还有，睡到天昏地暗。基本上第二天就没事了。如果把自己不开心的事和别人说，会打扰别人的好心情。如果经常找别人，会让人厌烦，所以我是很少主动的。也可以说，是懒。基本上我的电话，除了家人，很少再打给别人。&lt;/p&gt;

&lt;p&gt;正是基于这样的心态，我的好朋友来来回回都是那几个。所以生活也没有太大的变化。&lt;/p&gt;

&lt;p&gt;这个学期不再coding，时间多了。就时不时和基友们出去吃个饭，玩玩游戏，在宿舍打下火锅，打下牌。一个人就看看电影，听听音乐，刷刷微博，逛逛贴吧。反正所有浪费时间的事都干了。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;三、懂的道理&lt;/h4&gt;

&lt;p&gt;毕竟一年过去了，还是会有点感悟的吧。虽然很多都是鸡汤类文章的道理，但，不知道你有没有试过在某一瞬间突然醒悟：原来这样啊。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;大学里一个人吃饭，一个人学习是很正常的。这个道理我现在才懂。&lt;/li&gt;
  &lt;li&gt;脚踏实地，不要老想着干大事。&lt;/li&gt;
  &lt;li&gt;生活是很平凡的，所有要把每一天都过好。&lt;/li&gt;
  &lt;li&gt;不要羡慕别人所拥有的，你永远不知道多少人在羡慕你所拥有的。&lt;/li&gt;
  &lt;li&gt;学会思考比什么都重要。&lt;/li&gt;
  &lt;li&gt;在大学里，你可以挥霍你的所有，除了健康。&lt;/li&gt;
  &lt;li&gt;把字写清楚，尽量美观。&lt;/li&gt;
  &lt;li&gt;听歌不要听那些情情爱爱的，都没有经历过，听这些悲伤的歌曲只会破坏自己的心情。所以现在听最多的是欢快的英文歌。&lt;/li&gt;
  &lt;li&gt;写过的代码要备份，说不定哪一天还要用。&lt;/li&gt;
  &lt;li&gt;生活，要懂得感恩。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-3&quot;&gt;四、13没有完成的事和14要做的事&lt;/h4&gt;

&lt;p&gt;13年想做的事有很多。例如搭自己的博客，当时买了域名，空间，搭了个wordpress，不过觉得管理浪费时间，所以现在废弃了。想学python，ruby，linux shell，把js学好。更重要的是，没有好好锻炼身体，这个学期，虽然跑步坚持了几天，不过后来还是放弃了。哦，对了，还是没长高，还是小朋友的样子。&lt;/p&gt;

&lt;p&gt;13年想做的事太多太多。就不说了。&lt;/p&gt;

&lt;p&gt;14年想做的事嘛，这个要想想。
第一不用说肯定是锻炼身体。
定下心学技术。虽然不一定是前端，但也不会是java，不知道为什么不是很喜欢java。
尽量多的看书。技术性，文学性之类，反正不会是无厘头的小说。
多点时间出去游玩。如果这学期不挂科，下学期就只修3门了。这样就有很多空闲时间啦。说起来惭愧，这么大都没出过广东，所以对祖国的大好河山很是期待啊。
努力让自己变的睿智。因为要走气质路线，哈哈。
要去做一次家教。不是说没做过家教大学不完整么。做一次吧，也只做一次。
如果可以，努力兼职赚钱，买台mac pro，不要问我为什么，我是程序员。
当然，要把懒惰的缺点改掉啦。一定要。
如果如果如果如果有机会，去次西藏。&lt;/p&gt;

&lt;p&gt;总的来说，2013年没有让我发生太多的变化。也没有什么麻烦的事。期待2014吧。把自己想做的事和要做的事做好。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>无规矩不成方圆</title>
   <link href="jeffdeng.me/%E7%94%9F%E6%B4%BB/2013/12/22/rule"/>
   <updated>2013-12-22T00:00:00+08:00</updated>
   <id>jeffdeng.me/%E7%94%9F%E6%B4%BB/2013/12/22/rule</id>
   <content type="html">
&lt;p&gt;战国·邹·孟轲《孟子·离娄上》：“离娄之明，公输子之巧，不以规矩，不成方圆。”&lt;/p&gt;

&lt;p&gt;无规矩不成方圆–这个道理地球人都知道。当然，如果你不是，那。。。&lt;/p&gt;

&lt;p&gt;今天是冬至嘛，冬至在我心里一直都不知道是个什么日子，也许这是文化的凋零吧。哈，文化的凋零这些还轮不到我来下结论，还有大批砖家等着下这个结论开饭呢。反正就知道今天是有好东西吃的。然后昨晚就想：明天堕落一天吧！好。然后磨磨蹭蹭的到了3点，眼皮开始骂娘了才恋恋不舍，一放三收的把小机机放下。今天，好无悬念的，饿醒了。一看时间，卧槽，2点45,。赶紧一个死鱼挺尸爬起来，找食物去了。&lt;/p&gt;

&lt;p&gt;其实我前天的计划不是这样的啊！计划中，应该7点30神清气爽的醒来，感叹一下，早起的鸟儿有虫吃。然后潇洒的吃完早餐直奔自习室的，然后，开展挂机模式直到中午，然后吃完饭再睡个小觉，1点30再爬起来，毫不犹豫的再直奔自习室……&lt;/p&gt;

&lt;p&gt;好吧，我承认我有那么一点点高估了自己的能力了。随随便便的一个想法就可以把一个计划破坏的体无完肤。这让我的计划很没有存在感啊。虽然一直都是这样。&lt;/p&gt;

&lt;p&gt;突然，脑子里灵光一闪，无规则不成方圆啊。好像有点道理哈，这么一想。因为我的生活本来就是没有什么规则的，想干啥就干啥。注意，这里的是作息啊，做事啊之类的。前一晚才想好每晚要1点前睡，然后昨晚就直接忽视掉了。还美其名曰：看心情行事。妈蛋啊，这是要玩死自己的啊。&lt;/p&gt;

&lt;p&gt;地球不会因为你心情不好而停止不转，月亮也不会因为你的心情不好而弃地球而去，而你身边的所有事都不会因为你的心情不好而有所改变。本来是怎样，现在还是怎样。那自己的按心情办事在这个时候是不是就显得有点小傻呢？不是，是真傻！这和三岁小孩闹脾气有什么区别呢！虽然一直懂得这个道理，但还没有伤害到切身利益，所以就不以为然。这个道理其实和熬夜一样。&lt;/p&gt;

&lt;p&gt;所以，我决定，要定个生活的规则，以应对接下来狂轰滥炸的考试大军。（虽然不知道能坚持到什么时候，对于我这样的神一般的存在）&lt;/p&gt;

&lt;p&gt;晚上1点前睡觉，睡觉不玩手机，不看小说，不听音乐。早上7点30起来。
现在到考试前不要看电影，电影的时间太长了。
上课不玩手机，认真看书。
有空余时间不能老刷微博，逛贴吧。（模凌两可）&lt;/p&gt;

&lt;p&gt;恩，作为规则，那肯定有一点惩罚手段。想了一下，好像还真没什么惩罚手段呢。毕竟是自己定的规矩。
恩，破一条做十次俯卧撑好了。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>js之ajax学习笔记</title>
   <link href="jeffdeng.me/js/2013/03/23/ajax"/>
   <updated>2013-03-23T00:00:00+08:00</updated>
   <id>jeffdeng.me/js/2013/03/23/ajax</id>
   <content type="html">
&lt;h4 id=&quot;section&quot;&gt;起源:&lt;/h4&gt;

&lt;p&gt;XHR在IE5中引入，所以在IE中可能会遇到三种不同的版本 &lt;code&gt;MSXML2.XMLHttp.6.0&lt;/code&gt;, &lt;code&gt;MSXML2.XMLHttp.3.0&lt;/code&gt;，&lt;code&gt;MSXML2.XMLHttp&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;一、建立&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;适用于IE7之前的版本的创建方式
//适用于IE7之前的版本
function createXHR() {
	if ( typeof arguments.callee.activeXString != &quot;string&quot; ) {
		var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;,&#39;MSXML2.XMLHttp&#39;],
			i, len;
		for ( i = 0, len = versions.length; i &amp;lt; len; i++){
			try{
				new ActiveXObject( versions[i] );
				arguments.callee.activeXString = versions[i];
				break;
			}catch(ex){

			}
		}

	}
	return new ActiveXObject( arguments.callee.activeXString );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IE7+、Firefox、Opera、Chrome and Safari 都支持原生XHR&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//IE7+、Firefox、Opera、Chrome and Safari 都支持原生XHR
var xhr = new XMLHttpRequest();

所以兼容全部浏览器的方式是
//所以兼容全部浏览器的函数为
function createXHR() {
	if ( typeof XMLHttpRequest != &quot;undefined&quot; ) {
		return new XMLHttpRequest();
	}else if ( typeof ActiveXObject != &quot;undefined&quot; ) {
		if ( typeof arguments.callee.activeXString != &quot;string&quot; ) {
		var versions = [&#39;MSXML2.XMLHttp.6.0&#39;, &#39;MSXML2.XMLHttp.3.0&#39;,&#39;MSXML2.XMLHttp&#39;],
			i, len;
		for ( i = 0, len = versions.length; i &amp;lt; len; i++){
			try{
				new ActiveXObject( versions[i] );
				arguments.callee.activeXString = versions[i];
				break;
			}catch(ex){

			}
		}

	}
		return new ActiveXObject( arguments.callee.activeXString );
	} else {
		throw new Error(&quot;No XHR  object available.&quot;);
	} 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;xhr&quot;&gt;二、XHR的使用&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;1.OPEN()
//@param type(请求类型)  
//		 url(请求URL-相对于当前页面，也可以用绝对路径)
//		 isAsync(是否异步发送)
//调用open方法不会真正发送请求，只是启动一个请求以备发送
xhr.open(&quot;get/post&quot;, &quot;example.php&quot;, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.send()方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@param body 请求的主体内容，如果没有，设为null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.返回数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;responseText 作为响应主体被返回文本
responseXML 若响应类型为&quot;text/xml&quot;或&quot;application/xml&quot;,这个属性将保存包含响应   数据的XML DOM文档
status 响应的HTTP状态
statusText HTTP状态的说明
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.异步发送检测状态&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;readyState
0 --未初始化，尚未调用open();
1 --启动，已经调用open(),但尚未调用send();
2 --发送，已经调用send(),但尚未接收到响应;
3 --接收，已经接收到部分数据;
4 --完成，已经接收到全部响应数据，可以在客户端使用;
必须在调用open()之前调用readystatechange事件
xhr.onreadystatechange = function() {
	if( xhr.readyState == 4 ) {

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、HTTP头信息&lt;/p&gt;

&lt;p&gt;1.XHR默认请求头部&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Accept: 浏览器能够处理的内容类型
Accept-Charset: 浏览器能够显示的字符集
Accept-Encoding: 浏览器能够处理的压缩编码
Accept-Language: 浏览器当前设置语言
Connection: 浏览器与服务器之间的链接类型
Cookie: 当前页面设置的任何Cookie
Host: 发送请求页面的所在域
Referer: 发送请求的页面的URI
User-Agent: 浏览器的用户代理字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.设置头部&lt;/p&gt;

&lt;p&gt;调用&lt;code&gt;setRequestHeader()&lt;/code&gt;方法，两个参数，key-value必须在open()之后，send()之前调用注意，有的浏览器允许重写默认头部，有的不允许，所以最好使用自定义头部字段信息。&lt;/p&gt;

&lt;p&gt;3.获取头部字段&lt;/p&gt;

&lt;p&gt;调用&lt;code&gt;getResponseHeader()&lt;/code&gt;，参数 –头部字段&lt;code&gt;getAllResponseHeader()&lt;/code&gt;; 获取所有头部长字符串&lt;code&gt;getAllResponse-Headers()&lt;/code&gt;; 返回格式化的多行文本。&lt;/p&gt;

&lt;p&gt;4.get请求&lt;/p&gt;

&lt;p&gt;用于某些请求时，把查询字符串参数追加到URL末尾，但必须经过&lt;code&gt;encodeURIComponent()&lt;/code&gt;编码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/** 返回经过encodeURIComponent()编码的url参数
**@param url
*		 paramObj 参数对象 key-value
*/
function addURLParam(url, paramObj){
	if ( typeof paramObj != &quot;object&quot; ) return url;
	var tag = &#39;&#39;&#39;&#39;#&#39;&#39;&#39;&#39;;
	if ( url.indexOf(&quot;?&quot;) == &quot;-1&quot; ) tag = &#39;&#39;&#39;&#39;?&#39;&#39;&#39;&#39;;
	for( var key in paramObj ){
		url += tag + encodeURIComponent( key ) + &quot;=&quot; + encodeURIComponent( paramObj[key] );
		if( tag != &#39;&#39;&#39;&#39;#&#39;&#39;&#39;&#39; ) tag = &#39;&#39;&#39;&#39;#&#39;&#39;&#39;&#39;;
	}
	return url;
}

var url = &#39;&#39;&#39;&#39;http://www.baidu.com&#39;&#39;&#39;&#39;; 
var paramObj = {&quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;:&quot;value2&quot;, &quot;key3&quot;:&quot;value3&quot;};
addURLParam( url , paramObj );// &quot;http://www.baidu.com?key1=value1#key2=value2#key3=value3&quot;

var url = &#39;&#39;&#39;&#39;http://www.baidu.com&#39;&#39;&#39;&#39;; 
var paramObj = {&quot;key1&quot;:&quot;ss ss&quot;, &quot;key2&quot;:&quot;wqe2v&quot;, &quot;key3&quot;:&quot;sda/sa&quot;};
addURLParam( url , paramObj );//&quot;http://www.baidu.com?key1=ss%20ss#key2=wqe%02v#key3=sda%2Fsa&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.post请求&lt;/p&gt;

&lt;p&gt;模仿表单提交–设置&lt;code&gt;Content-Type&lt;/code&gt; 为 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
	xhr.onreadystatechange = function(){
	if ( xhr.readyState == 4 ){
	 		console.log( xhr.responseText );
		}
	};
	xhr.open(&quot;post&quot;, &quot;/hdzx/eventgetKTVEventList.action&quot;, true);
	xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);
	xhr.send(&quot;id: 196, opt: 1, page:1&quot;);

// Accept:*/*
// Accept-Charset:GBK,utf-8;q=0.7,*;q=0.3
// Accept-Encoding:gzip,deflate,sdch
// Accept-Language:zh-CN,zh;q=0.8
// Connection:keep-alive
// Content-Length:19
// Content-Type:application/x-www-form-urlencoded
// Cookie:cityID=202; JSESSIONID=C5D1BFB15CD2425E873A6CB35D153B46
// Host:www.minifang.cn
// Origin:http://www.minifang.cn
// Referer:http://www.minifang.cn/ktv/196.html
// User-Agent:Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.33 (KHTML, like Gecko) Chrome/27.0.1438.7 Safari/537.33
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;注意：get请求的速度最多可达post请求的两倍&lt;/code&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>IE6/IE7下：inline-block解决方案</title>
   <link href="jeffdeng.me/css/2013/03/16/inline-block"/>
   <updated>2013-03-16T00:00:00+08:00</updated>
   <id>jeffdeng.me/css/2013/03/16/inline-block</id>
   <content type="html">
&lt;p&gt;IE6/IE7下对&lt;code&gt;display:inline-block&lt;/code&gt;的支持性不好。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;inline&lt;/code&gt;元素的display属性设置为&lt;code&gt;inline-block&lt;/code&gt;时，所有的浏览器都支持；&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;block&lt;/code&gt;元素的display属性设置为&lt;code&gt;inline-block&lt;/code&gt;时，IE6/IE7浏览器是不支持的；&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行，允许空格。（准确地说，应用此特性的元素现为内联对象，周围元素保持在同一行，但可以设置宽度和高度等块元素的属性）

  IE中对内联元素使用display:inline-block，IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表征。从上面的这个分析，也不难理解为什么IE下，对块元素设置display:inline-block属性无法实现inline-block的效果。这时块元素仅仅是被display:inline-block触发了layout，而它本身就是行布局，所以触发后，块元素依然还是行布局，而不会如Opera中块元素呈递为内联对象。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IE6下块元素如何实现&lt;code&gt;display:inline-block&lt;/code&gt;的效果？&lt;/p&gt;

&lt;p&gt;有两种方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1 先使用display:inline-block属性触发块元素，然后再定义display:inline，让块元素呈递为内联对象（两个display 要先后放在两个CSS声明中才有效果，这是IE的一个经典bug，如果先定义了display:inline-block，然后再将display设回 inline或block，layout不会消失）。代码如下（…为省略的其他属性内容）：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  div {display:inline-block;...}
  div {display:inline;}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2 直接让块元素设置为内联对象呈递（设置属性display:inline），然后触发块元素的layout（如：zoom:1 或float属性等）。代码如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  div { display:inline-block; _zoom:1;_display:inline;} /*推荐*/
  div { display:inline-block; _zoom:1;*display:inline;} /*推荐:IE6/7*/
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>关于调整input里面的输入光标大小</title>
   <link href="jeffdeng.me/html/2013/03/09/input"/>
   <updated>2013-03-09T00:00:00+08:00</updated>
   <id>jeffdeng.me/html/2013/03/09/input</id>
   <content type="html">
&lt;p&gt;input输入框用一个背景图模拟，设置height和line-height一样的高度，使里面的输入文字能够居中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在FF下出现的情况是：点击input时，输入光标其实上跟input的height一样高，但当开始输入文字时，光标又变得跟文字一样高，&lt;/li&gt;
  &lt;li&gt;chrome下光标跟input的height一样高，&lt;/li&gt;
  &lt;li&gt;而IE下光标跟文字的大小一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一直没弄明白为什么这样子，今天听罗浮宫里的同学一讨论，才知道原因所在。&lt;/p&gt;

&lt;p&gt;初步结论如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;IE：不管该行有没有文字，光标高度与font-size一致。&lt;/li&gt;
  &lt;li&gt;FF：该行有文字时，光标高度与font-size一致。该行无文字时，光标高度与input的height一致。&lt;/li&gt;
  &lt;li&gt;Chrome：该行无文字时，光标高度与line-height一致；该行有文字时，光标高度从input顶部到文字底部(这两种情况都是在有设定line-height的时候)，如果没有line-height，则是与font-size一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决的方案：&lt;/p&gt;

&lt;p&gt;给input的height设定一个较小的高度，然后用padding去填充，基本上可以解决所有浏览器的问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input{
    height: 16px;
    padding: 4px 0px;
    font-size: 12px;
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>javascript数据类型</title>
   <link href="jeffdeng.me/js/2013/03/02/js-data-type"/>
   <updated>2013-03-02T00:00:00+08:00</updated>
   <id>jeffdeng.me/js/2013/03/02/js-data-type</id>
   <content type="html">
&lt;p&gt;5种数据类型：&lt;code&gt;undefined；null；boolean；number；string&lt;/code&gt;；
特殊：&lt;code&gt;object&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt;（操作符）：检测数据类型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;返回字符串；&lt;/li&gt;
  &lt;li&gt;返回object，是对象 或者 null；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;undefined&lt;/code&gt;：变量没初始化时；不用把值显式设置为undefined。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt;：空对象指针；要把值显示设置为null。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;：ture&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;false; 不是 Ture&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Flase；&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;一般情况：ture=1；false=0；&lt;/li&gt;
  &lt;li&gt;string：非空为ture；&lt;/li&gt;
  &lt;li&gt;number：非零数值（包括无穷大）为ture；&lt;/li&gt;
  &lt;li&gt;object：任何对象为ture；&lt;/li&gt;
  &lt;li&gt;undefined：n/a（不适用）为ture；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;number&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;八进制–第一位为0，数字:0~7；&lt;/li&gt;
  &lt;li&gt;十六进制–ox；数字0~9及A~F;字母可大写小写；&lt;/li&gt;
  &lt;li&gt;浮点数：小数点后没数值，ex：1.解析为1；整数，ex：10.0解析为10；浮点数值精确度不大好，ex：0.1+0.2=0.3000000000004；&lt;/li&gt;
  &lt;li&gt;数值范围：正无穷：Infinity；负无穷：-Infinity； –检测函数（位于最大最小值之间为true）：&lt;code&gt;isFinite()&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;NaN：非数值，与任何值都不相等，包括自身；–检测函数（接收一个参数，尝试把参数转换成数值，确定参数是否“不是数值”）：&lt;code&gt;isNaN()&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;数值转换：三函数–&lt;code&gt;Number()&lt;/code&gt;，&lt;code&gt;parseInt()&lt;/code&gt;和&lt;code&gt;parseFloat()&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Number()&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;null-&amp;gt;0;&lt;/li&gt;
  &lt;li&gt;undefined-&amp;gt;NaN；&lt;/li&gt;
  &lt;li&gt;字符串-&amp;gt;空的:0;其他格式:NaN;&lt;/li&gt;
  &lt;li&gt;对象：调用valueOf(),若转换为NaN，则调用对象的toString()；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;parseInt()&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;规则–忽略前面的空字符串，直到找到第一个非空字符串，若不是数字或符号，返回NaN;&lt;/li&gt;
  &lt;li&gt;字符串为空,返回NaN；&lt;/li&gt;
  &lt;li&gt;解析到非数字字符串，ex：1234.12返回1234；&lt;/li&gt;
  &lt;li&gt;0x»16进制；0»8进制；&lt;/li&gt;
  &lt;li&gt;由于E3，E5的区别，转换时可以再增加一个参数：ex：parseInt（“10”，2）；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;parseFloat()&lt;/code&gt;：第一个小数点有用，第二个小数点没有；只解析十进制;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;string&lt;/code&gt;：字符字面量，length包括字符字面量；字符串创建了就不能改变；要改变，先销毁；&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;toString()&lt;/code&gt;–null和undefined没有这种方法；参数，输出数值的基数，ex：toString(2)–二进制；&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;String()&lt;/code&gt;–不知道转换值是null或undefined时；null-&amp;gt;”null”,undefined-&amp;gt;”undeifined”&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 
</feed>
