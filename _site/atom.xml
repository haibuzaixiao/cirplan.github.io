<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>萝拔</title>
 <link href="jeffdeng.me/" rel="self"/>
 <link href="jeffdeng.me"/>
 <updated>2015-10-22T09:37:31+08:00</updated>
 <id>jeffdeng.me</id>
 <author>
   <name>dcirplan</name>
   <email>dcirplan@gmail.com</email>
 </author>

 
 <entry>
   <title>JS模块化开发（3）：require.js的使用以及压缩策略</title>
   <link href="jeffdeng.me/js/2015/10/19/js-requirejs"/>
   <updated>2015-10-19T00:00:00+08:00</updated>
   <id>jeffdeng.me/js/2015/10/19/js-requirejs</id>
   <content type="html">
&lt;p&gt;&lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;是遵循AMD规范的模块加载器，这里简单说说其用法和压缩策略。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;本文内容：&lt;/h2&gt;

&lt;p&gt;1.基本使用&lt;/p&gt;

&lt;p&gt;2.如何打包压缩&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基本使用&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1 加载&lt;/h3&gt;

&lt;p&gt;要使用require.js前提当然是先下载好或引入CDN。若下载好后，直接引入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script data-main=&quot;index&quot; src=&quot;/js/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里表示引入require.js后，把index.js作为程序的主模块，加载并执行。如果怕页面阻塞，可以把这段代码放到页面底部。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2 定义主模块&lt;/h3&gt;

&lt;p&gt;定义主模块可以使用&lt;code&gt;require&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// main.js
require([&#39;moduleA&#39;, &#39;moduleB&#39;, &#39;moduleC&#39;], function (moduleA, moduleB, moduleC){
    // some code here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以使用常规的定义模块的方式，用&lt;code&gt;define&lt;/code&gt;定义，因为&lt;code&gt;data-main&lt;/code&gt;已经指定这个是主模块了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// main.js
define([&#39;moduleA&#39;, &#39;moduleB&#39;, &#39;moduleC&#39;], function (moduleA, moduleB, moduleC){
    // some code here
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但有一种情况是一定要使用&lt;code&gt;require&lt;/code&gt;定义的，下面会说到。&lt;/p&gt;

&lt;h3 id=&quot;requirejs&quot;&gt;1.3 require.js配置&lt;/h3&gt;

&lt;p&gt;利用&lt;code&gt;require.config()&lt;/code&gt;，对require.js进行基本配置，&lt;code&gt;require.config()&lt;/code&gt;要放在主模块的头部，主要作用如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;定义基本目录；&lt;/li&gt;
  &lt;li&gt;对常用模块定义别名，方便引用；&lt;/li&gt;
  &lt;li&gt;定义文件版本号；&lt;/li&gt;
  &lt;li&gt;处理非AMD规范的模块；&lt;/li&gt;
  &lt;li&gt;处理非AMD规范并对其他模块产生依赖的模块；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// require.js config
require.config({
    baseUrl: &#39;/common/js&#39;, // 定义基本目录
    urlArgs: &#39;v=1.1.0&#39;,  // 定义请求js文件版本号
    paths: { // 常用模块别名
        &#39;angular&#39;    : &#39;lib/angular.min&#39;,
        &#39;sanitize&#39;   : &#39;lib/angular-sanitize.min&#39;,
        &#39;zepto&#39;      : &#39;lib/zepto.min&#39;
    },

    // 若加载模块不符合AMD规范，直接返回全局变量，则用下面方式封装
    // 切记：exports的变量一定要和返回的 全局变量名称 一致
    shim: {
        &#39;angular&#39;: {
	        exports: &#39;angular&#39;
        },
        &#39;sanitize&#39;: { // 对非AMD规范，对其他模块产生依赖依赖的要加上
	        deps: [&#39;angular&#39;],
	        exports: &#39;Sanitize&#39;
         },
        &#39;zepto&#39;: {
	       exports: &#39;Zepto&#39;
       }
    }

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个就是一个很常规的require.config配置。但在实际开发中，我们是不会把这段配置加在每个主模块的头部的，不然要修改点东西，就要一个一个改，岂不是要死的心都有。&lt;/p&gt;

&lt;p&gt;一般把上面的配置信息提成一个公共js，在require.js加载前加载。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;/js/config.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script data-main=&quot;index/index&quot; src=&quot;/js/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但如果直接把上面这段配置放在&lt;code&gt;config.js&lt;/code&gt;里会报&lt;code&gt;require is undefined&lt;/code&gt;。想想也是，require.js都还没有加载。所以我们修改下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// require.js config
var require = {
    baseUrl: &#39;/common/js&#39;, // 定义基本目录
    urlArgs: &#39;v=1.1.0&#39;,  // 定义请求js文件版本号
    paths: { // 常用模块别名
        &#39;angular&#39;    : &#39;lib/angular.min&#39;,
        &#39;sanitize&#39;   : &#39;lib/angular-sanitize.min&#39;,
        &#39;zepto&#39;      : &#39;lib/zepto.min&#39;
    },

    // 若加载模块不符合AMD规范，直接返回全局变量，则用下面方式封装
    // 切记：exports的变量一定要和返回的 全局变量名称 一致
    shim: {
        &#39;angular&#39;: {
	        exports: &#39;angular&#39;
        },
        &#39;sanitize&#39;: { // 对非AMD规范，对其他模块产生依赖依赖的要加上
	        deps: [&#39;angular&#39;],
	        exports: &#39;Sanitize&#39;
         },
        &#39;zepto&#39;: {
	       exports: &#39;Zepto&#39;
       }
    }

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就ok啦，现在可以想怎么折腾就怎么折腾了。&lt;/p&gt;

&lt;h3 id=&quot;amd&quot;&gt;1.4 AMD模块写法&lt;/h3&gt;

&lt;p&gt;关于AMD模块的定义，上一篇有介绍。直接定义在&lt;code&gt;define&lt;/code&gt;函数中。如我们要定义url模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// url.js
define(function (){
　　var getId = function (key) {
	    ...
    };

　　return {
       getId: getId
　　};
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// main.js
require([&#39;url&#39;], function (url){
　　alert(url.getId(&#39;index&#39;));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若定义有依赖的模块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&#39;util&#39;], function(util){
    function each(){
        util.doSomething();
        ...
    }
    return {
       each : each
    };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;2.如何打包压缩&lt;/h2&gt;

&lt;p&gt;由于使用模块化，文件会被分成很多个，这样在浏览器端无疑会产生很多HTTP请求，会让用户的等待时间加长。对于这个问题，require.js也提出了用&lt;code&gt;r.js&lt;/code&gt;合并压缩的方案。下面介绍r.js的使用。&lt;/p&gt;

&lt;p&gt;使用r.js要安装node.js环境，未安装的自行安装。&lt;/p&gt;

&lt;h3 id=&quot;rjs&quot;&gt;2.1 下载r.js&lt;/h3&gt;

&lt;p&gt;直接下载戳&lt;a href=&quot;http://requirejs.org/docs/release/2.1.11/r.js&quot;&gt;这里&lt;/a&gt;。或者直接用npm 安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g requirejs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2.2 文件目录&lt;/h3&gt;

&lt;p&gt;下面是示例的test目录：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test
    -html
        -index.html
    -dist
    -js
        -index
            -index.js
            -index2.js
        -lib
            -require.js
            -zepto.js
        -util
            -common.js
            -url.js
        -config.js
    -r.js
    -build.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;r.js&lt;/code&gt;放在根目录，&lt;code&gt;build.js&lt;/code&gt;为压缩配置文件，&lt;code&gt;dist&lt;/code&gt;为压缩后的输出目录。下面为对应js文件的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// index.js
define([&#39;zepto&#39;, &#39;index/index2&#39;, &#39;url&#39;], function($, index2, url){
    console.log(&#39;index&#39;);
});

// index2.js
define([&#39;url&#39;, &#39;util/common&#39;], function(url, common){
    console.log(&#39;index2&#39;);
});

// common.js
define([], function(){
    console.log(&#39;common&#39;);
});

// url.js
define([&#39;zepto&#39;], function($){
    console.log(&#39;url&#39;);
});

// config.js
var require = {
    baseUrl: &quot;../js&quot;,
    paths: {
        &quot;zepto&quot;: &quot;lib/zepto&quot;,
        &quot;url&quot;: &quot;util/url&quot;
    },
    shim: {
        &#39;zepto&#39;:{
        　　exports: &#39;Zepto&#39;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们来看看如何压缩。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;需求1&lt;/strong&gt; 把index.js及其依赖项合并压缩成一个js&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;({
    baseUrl: &#39;./js&#39;,  // 设置基本目录
    optimize: &#39;none&#39;, // 压缩方式：不压缩
    // path和shim配置要和config.js一样
    paths: { 
　　　　　　&quot;zepto&quot;: &quot;lib/zepto&quot;,
　　　　　　&quot;url&quot;: &quot;util/url&quot;
　　 },

    shim: {
        &#39;zepto&#39;:{
        　　exports: &#39;Zepto&#39;
        }
    },

    name: &#39;index/index&#39;, //设置要压缩的单个文件
    out : &#39;js/index/index-build.js&#39; // 设置要输出的文件名
})	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在命令行进入到项目的根目录，执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node r.js -o build.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以看到在index目录下会生成新的文件，其中最后一部分为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
  ;[&#39;swipe&#39;, &#39;swipeLeft&#39;, &#39;swipeRight&#39;, &#39;swipeUp&#39;, &#39;swipeDown&#39;, &#39;doubleTap&#39;, &#39;tap&#39;, &#39;singleTap&#39;, &#39;longTap&#39;].forEach(function(m){
    $.fn[m] = function(callback){ return this.bind(m, callback) }
  })
})(Zepto)
;
define(&quot;zepto&quot;, (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Zepto;
    };
}(this)));

define(&#39;url&#39;,[&#39;zepto&#39;], function($){
	console.log(&#39;url&#39;);
});
define(&#39;util/common&#39;,[], function(){
	console.log(&#39;common&#39;);
});
define(&#39;index/index2&#39;,[&#39;url&#39;, &#39;util/common&#39;], function(url, common){
	console.log(&#39;index2&#39;);
});
define(&#39;index/index&#39;,[&#39;zepto&#39;, &#39;index/index2&#39;, &#39;url&#39;], function($, index2, url){
	console.log(&#39;index&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;需求2&lt;/strong&gt; 把index.js和index2.js批量分别合并&lt;/p&gt;

&lt;p&gt;因为在实际开发中很难像上面一个一个合并，所以批量合并是比较好得方法。修改build.js如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;({
    baseUrl: &#39;./js&#39;,  // 设置基本目录
    dir: &#39;./dist&#39;, // 设置输出目录
    optimize: &#39;none&#39;, // 压缩方式：不压缩
    // path和shim配置要和config.js一样
    paths: { 
　　　　　　&quot;zepto&quot;: &quot;lib/zepto&quot;,
　　　　　　&quot;url&quot;: &quot;util/url&quot;
　　 },

    shim: {
        &#39;zepto&#39;:{
        　　exports: &#39;Zepto&#39;
        }
    },

    modules : [
        {
            name: &#39;index/index&#39;
        },

        {
            name: &#39;index/index2&#39;
        }
    ]
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样会在&lt;code&gt;dist&lt;/code&gt;目录下生成一系列文件，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20151019requirejs/out1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于module数组里不要求合并的js，是和原来一样的。&lt;/p&gt;

&lt;p&gt;调用直接调用这样就这样了，config.js都不用加载了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script data-main=&quot;../dist/index/index.js&quot; src=&quot;../js/lib/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;需求3&lt;/strong&gt; 把zepto.js和url.js等公用文件合并成一个文件，index.js和index2.js如果有依赖这些文件时的，在合并的时候自动忽略&lt;/p&gt;

&lt;p&gt;因为把所有页面的js都压缩成一个，公用的部分每次都加载，未免会增加等待时间，所以把公用部分抽出来是一个比较好的选择。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;({
    baseUrl: &#39;./js&#39;,  // 设置基本目录
    dir: &#39;./dist&#39;, // 设置输出目录
    optimize: &#39;none&#39;, // 压缩方式：不压缩
    // path和shim配置要和config.js一样
    paths: { 
　　　　　　&quot;zepto&quot;: &quot;lib/zepto&quot;,
　　　　　　&quot;url&quot;: &quot;util/url&quot;
　　 },

    shim: {
        &#39;zepto&#39;:{
        　　exports: &#39;Zepto&#39;
        }
    },

    modules : [
        {
            name: &#39;lib/common&#39;,
            create: true,
            include: [&#39;zepto&#39;, &#39;url&#39;]
        },

        {
            name: &#39;index/index&#39;,
            exclude: [
                &#39;zepto&#39;,
                &#39;url&#39;
            ]
        },

        {
            name: &#39;index/index2&#39;,
            exclude: [
                &#39;zepto&#39;,
                &#39;url&#39;
            ]
        }
    ]
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到&lt;code&gt;dist/lib&lt;/code&gt;下生成了&lt;code&gt;common.js&lt;/code&gt;，而index.js变成了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// index.js
define(&#39;util/common&#39;,[], function(){
	console.log(&#39;common&#39;);
});
define(&#39;index/index2&#39;,[&#39;url&#39;, &#39;util/common&#39;], function(url, common){
	console.log(&#39;index2&#39;);
});
require([&#39;zepto&#39;, &#39;index/index2&#39;, &#39;url&#39;], function($, index2, url){
	console.log(&#39;index&#39;);
});
define(&quot;index/index&quot;, function(){});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改&lt;code&gt;config.js&lt;/code&gt;如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var require = {
    baseUrl: &quot;../js&quot;,
    paths: {
        &quot;zepto&quot;: &quot;../dist/lib/common&quot;,
        &quot;url&quot;: &quot;../dist/lib/common&quot;
    },

    shim: {
        &#39;zepto&#39;:{
        　　exports: &#39;Zepto&#39;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后直接请求:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;../js/config.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script data-main=&quot;../dist/index/index.js&quot; src=&quot;../js/lib/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就有公用模块了。更多r.js的配置看&lt;a href=&quot;https://github.com/jrburke/r.js/blob/master/build/example.build.js&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;如果觉得requrejs压缩后还是很大，可以尝试使用require.js作者的另一个开源项目&lt;a href=&quot;https://github.com/jrburke/almond&quot;&gt;almond.js&lt;/a&gt;。almond.js压缩后最小为1k左右。
但有一个很重要的限制：所有模块必须压缩在一个文件里。almond.js的使用可以看&lt;a href=&quot;http://levi.yii.so/archives/3450&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最后，选择哪种压缩策略看项目的具体需要。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>JS模块化开发（2）：AMD与CMD规范</title>
   <link href="jeffdeng.me/js/2015/10/18/js-amd-cmd"/>
   <updated>2015-10-18T00:00:00+08:00</updated>
   <id>jeffdeng.me/js/2015/10/18/js-amd-cmd</id>
   <content type="html">
&lt;p&gt;接着&lt;a href=&quot;/js/2015/10/17/js-module/&quot;&gt;上一篇&lt;/a&gt;，这里说下AMD与CMD规范。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;本文内容：&lt;/h2&gt;

&lt;p&gt;1.AMD规范&lt;/p&gt;

&lt;p&gt;2.CMD规范&lt;/p&gt;

&lt;p&gt;3.AMD规范CMD规范的异同点&lt;/p&gt;

&lt;h2 id=&quot;amdrequirejs&quot;&gt;1.AMD规范（代表require.js）&lt;/h2&gt;

&lt;p&gt;AMD规范的英文文档看&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;这里&lt;/a&gt;，中文版看&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88)&quot;&gt;这里&lt;/a&gt;（选择细看文档的话，下面不用看了）。AMD全称是Asynchronous Module Definition（异步模块定义规范），规定了模块与模块之间是异步加载的，
这和浏览器的异步加载模块的环境刚好适应（浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题）。&lt;/p&gt;

&lt;p&gt;该规范只定义了一个全局函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(id?, dependencies?, factory);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;id-&quot;&gt;id 名字&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;类型：字符串；&lt;/li&gt;
  &lt;li&gt;特点：唯一，可选，默认为脚本名字。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dependencies-&quot;&gt;dependencies 依赖&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;类型：数组；&lt;/li&gt;
  &lt;li&gt;执行顺序：依赖模块必须根据模块的工厂方法优先级执行（依赖少的先执行），并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中；&lt;/li&gt;
  &lt;li&gt;模块命名：如果是相对的，应该解析为相对定义中的模块。&lt;/li&gt;
  &lt;li&gt;关键字： 三种特殊的依赖关键字&lt;code&gt;require&lt;/code&gt;,&lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;，是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。
然而，如果工厂方法的形参个数小于3，加载器会选择以函数指定的参数个数调用工厂方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建一个名为”alpha”的模块，使用了require，exports，和名为”beta”的模块:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&quot;alpha&quot;, [&quot;require&quot;, &quot;exports&quot;, &quot;beta&quot;], function (require, exports, beta) {
   exports.verb = function() {
       return beta.verb();
       //Or:
       return require(&quot;beta&quot;).verb();
   }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;factory-&quot;&gt;factory 工厂方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;类型：函数或对象；&lt;/li&gt;
  &lt;li&gt;特点：函数只执行一次&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个没有依赖性的模块可以直接定义对象：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define({
  add: function(x, y){
    return x + y;
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;commonjs-&quot;&gt;简单的 CommonJS 转换&lt;/h3&gt;

&lt;p&gt;为了向CommonJS靠拢而加的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function (require, exports, module) {
 var a = require(&#39;a&#39;),
     b = require(&#39;b&#39;);

 exports.action = function () {};
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这会被转换成规范模式再执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&quot;a&quot;, &quot;b&quot;], function (a, b) {
  	...
    exports.action = function () {};
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在require.js（v2.1.20 line2052）中的实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//If no name, and callback is a function, then figure out if it a
//CommonJS thing with dependencies.
if (!deps &amp;amp;&amp;amp; isFunction(callback)) {
    deps = [];
    //Remove comments from the callback string,
    //look for require calls, and pull them into the dependencies,
    //but only if there are function args.
    if (callback.length) {
        callback
            .toString()
            .replace(commentRegExp, &#39;&#39;)
            .replace(cjsRequireRegExp, function (match, dep) {
                deps.push(dep);
            });

        //May be a CommonJS thing even without require calls, but still
        //could use exports, and module. Avoid doing exports and module
        //work though if it just needs require.
        //REQUIRES the function to expect the CommonJS variables in the
        //order listed below.
        deps = (callback.length === 1 ? [&#39;require&#39;] : [&#39;require&#39;, &#39;exports&#39;, &#39;module&#39;]).concat(deps);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但在某些情况下，因为脚本大小的限制或函数不支持toString方法（Opera Mobile是已知的不支持函数的toString方法），模块加载器可以选择扫描不扫描依赖性。
如果有依赖参数，模块加载器不应该在工厂方法中扫描依赖性。&lt;/p&gt;

&lt;h2 id=&quot;cmdseajs&quot;&gt;2.CMD规范（代表sea.js）&lt;/h2&gt;

&lt;p&gt;CMD(Common Module Definition)规范戳&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;这里&lt;/a&gt;。该规范规定一个模块就是一个文件，定义的函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(factory);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;define是全局函数；&lt;/li&gt;
  &lt;li&gt;factory可以是一个函数，也可以是一个对象或字符串；&lt;/li&gt;
  &lt;li&gt;factory为函数时，默认传入三个参数：&lt;code&gt;require&lt;/code&gt;、&lt;code&gt;exports&lt;/code&gt; 和 &lt;code&gt;module&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {
  // 模块代码
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CMD也支持如下写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(id?, deps?, factory)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字符串 id 表示模块标识，数组 deps 是模块依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(&#39;hello&#39;, [&#39;jquery&#39;], function(require, exports, module) {
  // 模块代码
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，带 id 和 deps 参数的 define 用法不属于 CMD 规范，而属于 &lt;a href=&quot;https://github.com/cmdjs/specification/blob/master/draft/transport.md&quot;&gt;Modules/Transport&lt;/a&gt; 规范。&lt;/p&gt;

&lt;p&gt;下面分别说说&lt;code&gt;require&lt;/code&gt;，&lt;code&gt;exports&lt;/code&gt;，&lt;code&gt;module&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;require&quot;&gt;require&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;require&lt;/code&gt;是 factory 函数的第一个参数，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {

  // 获取模块 a 的接口
  var a = require(&#39;./a&#39;);

  // 调用模块 a 的方法
  a.doSomething();

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;require.async&lt;/code&gt; require.async(id, callback?) 方法用来在模块内部异步加载模块，并在加载完成后执行指定回调。callback 参数可选。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {

  // 异步加载一个模块，在加载完成时，执行回调
  require.async(&#39;./b&#39;, function(b) {
    b.doSomething();
  });

  // 异步加载多个模块，在加载完成时，执行回调
  require.async([&#39;./c&#39;, &#39;./d&#39;], function(c, d) {
    c.doSomething();
    d.doSomething();
  });

});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;exports&quot;&gt;exports&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;exports&lt;/code&gt;是一个对象，用来向外提供模块接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports) {

  // 对外提供 foo 属性
  exports.foo = &#39;bar&#39;;

  // 对外提供 doSomething 方法
  exports.doSomething = function() {};

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了给 exports 对象增加成员，还可以使用 return 直接向外提供接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require) {

  // 通过 return 直接提供接口
  return {
    foo: &#39;bar&#39;,
    doSomething: function() {}
  };

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提示：exports 仅仅是 module.exports 的一个引用。在 factory 内部给 exports 重新赋值时，并不会改变 module.exports 的值。因此给 exports 赋值是无效的，不能用来更改模块接口。&lt;/p&gt;

&lt;h3 id=&quot;module&quot;&gt;module&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;module&lt;/code&gt; 是一个对象，上面存储了与当前模块相关联的一些属性和方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;module.exports&lt;/code&gt; 当前模块对外提供的接口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define(function(require, exports, module) {

  // exports 是 module.exports 的一个引用
  console.log(module.exports === exports); // true

  // 重新给 module.exports 赋值
  module.exports = new SomeClass();

  // exports 不再等于 module.exports
  console.log(module.exports === exports); // false

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：对 module.exports 的赋值需要同步执行，不能放在回调函数里。下面这样是不行的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// x.js
define(function(require, exports, module) {

  // 错误用法
  setTimeout(function() {
    module.exports = { a: &quot;hello&quot; };
  }, 0);

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CMD经常使用的 API 只有 &lt;code&gt;define, require, require.async, exports, module.exports&lt;/code&gt; 这五个。其他请看规范。&lt;/p&gt;

&lt;h2 id=&quot;amdcmd&quot;&gt;3.AMD规范CMD规范的异同点&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;相同点&lt;/h3&gt;

&lt;p&gt;AMD与CMD的相同点是：都是 &lt;strong&gt;异步提前加载&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// AMD 
define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) { 
   //在此时模块a和b都已加载完
});

// CMD
define(function(require, exports, module) {
    //在此时模块a和b都已加载完
    var a = require(&#39;./a&#39;); 
    a.doSomething();
	...

    var b = require(&#39;./b&#39;);
    b.doSomething();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;不同点&lt;/h3&gt;

&lt;p&gt;而两者的区别，在上一篇中的AMD和CommonJS的区别已经说了一部分。玉伯在&lt;a href=&quot;http://www.zhihu.com/question/20351507/answer/14859415&quot;&gt;知乎&lt;/a&gt;也有回答，或者看&lt;a href=&quot;https://github.com/seajs/seajs/issues/277&quot;&gt;这里&lt;/a&gt;。主要有俩个，一个是执行时机不同，还有一个是书写风格不同。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.执行时机&lt;/h4&gt;

&lt;p&gt;AMD是 &lt;strong&gt;提前执行&lt;/strong&gt;，CMD是 &lt;strong&gt;延迟执行&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// AMD 
define([&#39;./a&#39;], function(a) { 
    // 在这之前a已经执行完并返回
    a.doSomething()；
	...
});

// CMD
define(function(require, exports, module) {
    var a = require(&#39;./a&#39;); // 模块a在此时才执行
    a.doSomething();
	...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-4&quot;&gt;2.书写风格&lt;/h4&gt;

&lt;p&gt;CMD 推崇&lt;strong&gt;依赖就近&lt;/strong&gt;，AMD 推崇&lt;strong&gt;依赖前置&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// CMD
define(function(require, exports, module) {
    var a = require(&#39;./a&#39;);
    a.doSomething();
    // 此处略去 100 行
    var b = require(&#39;./b&#39;); // 依赖可以就近书写
    b.doSomething();
    // ... 
});

// AMD 默认推荐的是
define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) { // 依赖必须一开始就写好
    a.doSomething();
    // 此处略去 100 行
    b.doSomething();
    ...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt;

&lt;p&gt;选择AMD还是CMD要看项目的需求和自己对写法的偏好，并没有绝对说哪个比哪个好。require.js成名较早，人气比较高。sea.js小而优雅，
文档支持也比较好，国内还是有比较多人使用的。&lt;/p&gt;

&lt;p&gt;下面介绍&lt;code&gt;require.js&lt;/code&gt;的使用，请看下一篇：&lt;a href=&quot;/js/2015/10/19/js-requirejs/&quot;&gt;require.js的使用以及压缩策略&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>JS模块化开发（1）：历史</title>
   <link href="jeffdeng.me/js/2015/10/17/js-module"/>
   <updated>2015-10-17T00:00:00+08:00</updated>
   <id>jeffdeng.me/js/2015/10/17/js-module</id>
   <content type="html">
&lt;pre&gt;&lt;code&gt;开篇感言：一直以来懒散的很，以为想改就改，无须过于在意。但现在发现懒散的态度已经融到骨子里了，还能改否？曰：难。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;前言：&lt;/h3&gt;

&lt;p&gt;JS模块化在现在早已不是一个新鲜的词语，随便在网络上搜一下都有一大堆文献资料，简单的、详细的应有尽有。
而我最近才开始关注这方面，没有见证到09年以来COMMOMJS标准的诞生，AMD和CMD的崛起，未免是一个遗憾。
所以这里整理下JS模块化的发展历程。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;本文内容：&lt;/h3&gt;

&lt;p&gt;1.为什么需要模块化&lt;/p&gt;

&lt;p&gt;2.模块化的发展历程&lt;/p&gt;

&lt;p&gt;3.AMD和CommonJS的区别&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.为什么需要模块化&lt;/h3&gt;

&lt;p&gt;为什么需要模块化，玉伯大大的这篇&lt;a href=&quot;https://github.com/seajs/seajs/issues/547&quot;&gt;前端模块化开发的价值&lt;/a&gt;应该很好解答你的疑问。
文章中提到的两点：&lt;code&gt;命名冲突&lt;/code&gt;和&lt;code&gt;文件依赖&lt;/code&gt;问题的确是JS一直以来的痛处。由与JS是10天内诞生的，所以没有其他高大上编程语言尽善尽美的模块管理机制。
但不管这是作者的刻意为之还是兼顾不到，从ES6的规范来看，模块化已经是大势所趋了。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1.1命名冲突&lt;/h4&gt;

&lt;p&gt;JS是一门容错性很高的语言，定义变量不需要定义类型，对于重复的命名既不会报错也不会停止执行。看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 重复声明
var a = 1;
var a;
console.log(a); // 1

// 重复声明&amp;amp;赋值
var a = 1;
var a = 2;
console.log(a); // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的例子很好理解，JS的变量是先声明再赋值的，所以对于重复声明是没有影响的。但重复赋值就会把之前的值覆盖掉。如果在团队开发中，我无心把你的覆盖了，
你无意把我写的覆盖了，等合并代码后，觉得整个码生都是灰暗的。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;1.2模块依赖&lt;/h4&gt;

&lt;p&gt;模块依赖在项目不大，或者不算复杂的情况还不算什么问题。但当项目代码数量上来了，管理模块依赖简直要命。最古老的方法就是人肉依赖：什么？引入这个
JS文件报错了？之前不是用的没问题吗？应该是出BUG了，看下谁写的，叫他来看看……如果你是作者对于这样的事情是不是觉得有点无奈，不由地感叹：时间都去哪了。
当然，可以在JS文件的头注释上把要依赖的文件列出来。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;1.3常规处理&lt;/h4&gt;

&lt;p&gt;既然这俩个问题早就有了，那之前是怎么处理的呢？控制好作用域&amp;amp;采用自执行函数生成对象。参考阮一峰老师的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/javascript_module.html&quot;&gt;Javascript模块化编程（一）：模块的写法&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a.常规的对象生成方法：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var module1 = new Object({
	_count : 0,

	m1 : function (){
	　　　//...
	},

	m2 : function (){
	//...
	}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在一定程度上减少变量的重复命名，调用直接 &lt;code&gt;module1.m1()&lt;/code&gt; 就可以了。但缺点也很明显，可以直接修改对象内部的属性，模块之间看不出关联。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b.采用立即执行函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var module1 = (function(){
　　var _count = 0;
　　var m1 = function(){
　　　　//...
　　};
　　var m2 = function(){
　　　　//...
　　};
　　return {
　　　　m1 : m1,
　　　　m2 : m2
　　};
})();
console.info(module1._count); //undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样对象内部属性就修改不了。但这样看不出模块之间的依赖。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c.输入全局变量&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;显式地将其他变量输入模块，可以明确模块依赖。ex：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var module1 = (function ($, YAHOO) {
　　//...
})(jQuery, YAHOO);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在没有模块加载器的情况下，这样算是比较好的解决方案了。一方面限制了变量作用域，另外显示把依赖输入模块，一目了然。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;2.模块化的发展历程&lt;/h3&gt;

&lt;p&gt;参考玉伯的&lt;a href=&quot;https://github.com/seajs/seajs/issues/588&quot;&gt;前端模块化开发那点历史&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在2009年，ServerJS诞生了，其社区推出&lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules&quot;&gt;Modules/1.0&lt;/a&gt;规范，Node.js采用部分该规范并获得不错的效果。ex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = require(&#39;./a&#39;)  // 加载模块（同步加载）
a.doSomething()         // 等上一句执行完才会执行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ServerJS为了把这套规范推到浏览器端，就改名叫做CommonJS，同时激烈争论Modules的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：&lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;Modules/1.x&lt;/strong&gt; 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Transport&quot;&gt;Modules/Transport&lt;/a&gt; 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 &lt;a href=&quot;https://github.com/componentjs/component&quot;&gt;component&lt;/a&gt; 和走在前沿的 &lt;a href=&quot;https://github.com/esnext/es6-module-transpiler&quot;&gt;es6 module transpiler&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;2.&lt;strong&gt;Modules/Async&lt;/strong&gt; 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition&quot;&gt;AMD&lt;/a&gt; 规范及其实现 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;3.&lt;strong&gt;Modules/2.0&lt;/strong&gt; 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 &lt;a href=&quot;https://code.google.com/p/bravojs/&quot;&gt;BravoJS&lt;/a&gt; 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 &lt;a href=&quot;http://www.page.ca/~wes/CommonJS/modules-2.0-7/&quot;&gt;Modules/2.0-draft&lt;/a&gt; 规范花了很多心思。FlyScript 的作者提出了 &lt;a href=&quot;http://wiki.commonjs.org/wiki/Modules/Wrappings&quot;&gt;Modules/Wrappings&lt;/a&gt; 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。&lt;/p&gt;

&lt;h3 id=&quot;amdcommonjs&quot;&gt;3.AMD和CommonJS的区别&lt;/h3&gt;

&lt;h4 id=&quot;section-7&quot;&gt;1.执行时机有区别&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Modules/1.0:
var a = require(&quot;./a&quot;) // 执行到此时，a.js 才同步下载并执行

// AMD:
define([&quot;a&quot;], function(a) {
  // 在这里，模块 a 已经下载并执行好
  // ...

})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AMD 里提前下载 a.js 是浏览器的限制，没办法做到同步下载，这个社区都认可。但执行，AMD 里是 Early Executing，Modules/1.0 里是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的也不能接受。这个差异，也导致实质上 Node 的模块与 AMD 模块是无法共享的，存在潜在冲突。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;2.模块书写风格有争议&lt;/h4&gt;

&lt;p&gt;AMD 风格下，通过参数传入依赖模块，破坏了 &lt;strong&gt;就近声明&lt;/strong&gt; 原则。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) {

    // 等于在最前面申明并初始化了要用到的所有模块

   if (false) {
       // 即便压根儿没用到某个模块 b，但 b 还是提前执行了
       b.foo()
   }

})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有就是 AMD 下 require 的用法，以及增加了全局变量 define 等细节，当时在社区被很多人不认可。&lt;/p&gt;

&lt;p&gt;最后，AMD 从 CommonJS 社区独立了出去，单独成为了 AMD 社区。这样的结局不免的让人唏嘘不已。&lt;/p&gt;

&lt;p&gt;下一篇：&lt;a href=&quot;/js/2015/10/18/js-amd-cmd/&quot;&gt;AMD与CMD的规范&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/547&quot;&gt;https://github.com/seajs/seajs/issues/547&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/588&quot;&gt;https://github.com/seajs/seajs/issues/588&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://huangxuan.me/2015/05/25/js-module-loader/&quot;&gt;JavaScript Module Loader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>穿越东西冲</title>
   <link href="jeffdeng.me/trip/2015/09/19/cross"/>
   <updated>2015-09-19T00:00:00+08:00</updated>
   <id>jeffdeng.me/trip/2015/09/19/cross</id>
   <content type="html">
&lt;p&gt;周三的时候突然想去东西冲穿越，然后约了朋友，周六果断去了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;路线&lt;/h2&gt;

&lt;p&gt;我们是先坐地铁到竹子林，然后到福田交通枢纽公交站（就在地铁站旁边）坐H92公交车到大鹏。因为是首发站，所以车上会有很多位置。刷深圳通是11块，如果给钱的话是13块。&lt;/p&gt;

&lt;p&gt;到大鹏途中大概要两个小时左右，到了大鹏，可以选择去东冲还是去西冲。去西冲有1号线和2号线两个入口。我们是下了H92再坐232小巴到西冲的2号线。&lt;/p&gt;

&lt;p&gt;到了西冲，入口每个人要收13块。继续走就到了西冲的沙滩边，然后往左边就是去东冲的方向了。&lt;/p&gt;

&lt;p&gt;到了东冲可以坐231小巴回大鹏。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;物品&lt;/h2&gt;

&lt;p&gt;首先长袖，长裤，帽子什么的都是很有必要的！很有必要！很有必要！可以适当涂点防晒霜（因为我穿短袖短裤，没有帽子，然后裸露的皮肤全都晒伤了，红通通的，一摸就疼，哭）。防晒一定要做好！&lt;/p&gt;

&lt;p&gt;然后我们还买了手套，事实证明手套也是很有必要的，因为你要不断的攀岩啊（不骗人）。一副好的手套可以让穿越过程的难度降低30%左右～&lt;/p&gt;

&lt;p&gt;其他最重要的是水，因为穿越途中是没有水买的。我们三个人，买了两瓶大的和三瓶小的矿泉水，差不多喝完。其他吃的可以自己看心情选购，有一点是：在穿越过程中是不想吃东西的，最好在启程的时候就吃掉。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;时间&lt;/h2&gt;

&lt;p&gt;我们是12点12分从西冲开始出发（正是最晒的时候），到东冲的时候，是下午4点19分。历时4个小时零7分，算是比较正常的时间吧。&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;看图时刻&lt;/h1&gt;

&lt;p&gt;由于是用手机拍的，图片质量不是很好（没错，我还压缩了）。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;西冲&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;往东冲的方向&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;开始&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/8.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;第一个小山头&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/9.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;在休息&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/11.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;另外一个很陡的小山头&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/12.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/13.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;又一个小山头&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/14.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-11&quot;&gt;后面的山&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/15.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/16.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-12&quot;&gt;全景&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/17.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/19.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-13&quot;&gt;从上面滚着下来&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/20.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-14&quot;&gt;地面时刻&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/21.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-15&quot;&gt;好想游泳&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/22.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-16&quot;&gt;全景2&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/23.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-17&quot;&gt;回望&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/24.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-18&quot;&gt;过不去了&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/25.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-19&quot;&gt;回望&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/26.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-20&quot;&gt;山顶&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/27.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/28.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-21&quot;&gt;大海&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/30.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-22&quot;&gt;终点–东冲&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/images/2015/20150919cross/31.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-23&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;如果让有经验的人带一下会安全很多，一个人走会比较危险。整个过程还是刺激又好玩的，比爬山好玩多了，但没爬山安全踏实。时间要安排好，不然走到中间天黑了就麻烦了。周末会比较多人，大部分都是从东冲到西冲。跟着大部队的话不会走上歪路。&lt;/p&gt;

&lt;p&gt;恩，刺激，好玩。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>canvas分辨率问题</title>
   <link href="jeffdeng.me/js/2015/07/06/canvas-resolution"/>
   <updated>2015-07-06T00:00:00+08:00</updated>
   <id>jeffdeng.me/js/2015/07/06/canvas-resolution</id>
   <content type="html">
&lt;p&gt;过程：最近尝试用H5的canvas写了个小游戏，然后加载图片的时候发现，在电脑上图片是很清晰的，但到了手机上就看到比较模糊（图片都是实际大小的2倍）。&lt;/p&gt;

&lt;p&gt;再现：demo代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.onload = function () {
	var canvas = document.getElementById(&#39;canvas1&#39;);
	var ctx = canvas.getContext(&quot;2d&quot;);
	var width, height;
	width = 320;
	height = 568;

	canvas.style.width = width+&#39;px&#39;;
	canvas.style.height = height + &#39;px&#39;;
	canvas.width = width; 
	canvas.height = height;
	var img = new Image();
	img.src = &quot;../img/s6_1.png&quot;;
	img.onload = function () {  
	    ctx.drawImage(img, 20, 20, img.width/2, img.height/2); 
	}  
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先看效果图（左边为电脑模拟，右边为手机）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/1_pc.png&quot; alt=&quot;电脑&quot; /&gt;
&lt;img src=&quot;/images/2015/20150706canvas/2_phone.jpg&quot; alt=&quot;手机&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有没有发现什么？认真看就会发现：右边的图比较模糊（如果实在没发现请自戳双目，为什么？因为留着没用）。&lt;/p&gt;

&lt;p&gt;所以现在问题是：&lt;code&gt;为什么canvas加载图片在手机上会显示模糊？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先我们看看上面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;canvas.style.width = width+&#39;px&#39;;
canvas.style.height = height + &#39;px&#39;;
canvas.width = width; 
canvas.height = height;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样子写是不是有点多此一举了？闲的蛋疼？为了证明不是蛋疼，首先我们要了解&lt;code&gt;设备像素&lt;/code&gt;和&lt;code&gt;CSS像素&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;css&quot;&gt;设备像素和CSS像素&lt;/h3&gt;

&lt;p&gt;设备像素就是我们平时所说的设备真实像素，像iPhone5s的 640 x 1136。但一般开发者是不怎么关心这个数值的，因为有CSS像素。&lt;/p&gt;

&lt;p&gt;CSS像素是我们平时代码直接用的，iPhone5s的CSS像素为 320 x 568（这样子应该懂了吧）。&lt;/p&gt;

&lt;p&gt;由于设备像素和CSS像素不一样，所以设备会用几个设备像素表示一个CSS像素。像iPhone5s就是4个设备像素点表示一个CSS像素。如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/3_px.gif&quot; alt=&quot;像素比例&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里就有一个很常见的问题：为什么图片在retina屏中会模糊？&lt;/p&gt;

&lt;p&gt;例如要显示 100px x 100px 的图片，如果切出来的图片也是 100px x 100px，那么在iPhone5s下是肯定会模糊的。
因为iPhone5s的 设备像素/CSS像素 比是2。所以它需要的图片实际大小为 200px x 200px。如果像现在这样大小不够呢？那像素点只能被扩充了。&lt;/p&gt;

&lt;p&gt;什么是扩充？就是5s的4个设备像素点表示1个CSS像素点时候，本应该4个像素点都有各自的颜色的，但图片小了，那4个设备像素点都是复制成同一种颜色。十分简单粗暴的方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;canvas的显示也是类似于图片，如果不够大就会被扩充。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;canvas.width/height&lt;/code&gt; 表示的是设备像素，而 &lt;code&gt;canvas.style.width/height&lt;/code&gt; 表示的是CSS像素。所以设置&lt;code&gt;canvas.width/height==canvas.style.width/height&lt;/code&gt;的时候，如果 设备像素/CSS像素 不是1，canvas就被扩充了，然后图片加载进去，虽然是2倍实际大小，但还是模糊掉了（这里没想通？再想想）。这样就很好解析刚刚的例子在电脑端没有模糊（我的电脑像素比是1），但在手机端却模糊了（还不明白？不是我的问题就是你的问题了）。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;解决方法&lt;/h3&gt;

&lt;p&gt;既然问题出现了，总是会有解决方法的。先看两个参数 &lt;code&gt;devicePixelRatio&lt;/code&gt;和&lt;code&gt;webkitBackingStorePixelRatio&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;devicepixelratio&quot;&gt;devicePixelRatio&lt;/h4&gt;

&lt;p&gt;devicePixelRatio是window下的属性，是 设备像素/CSS像素 的比值。下面列出了一些：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;iPhone5s 		2&lt;/li&gt;
  &lt;li&gt;iPhone6 plus  3&lt;/li&gt;
  &lt;li&gt;nexus7 		1.3 (非常奇葩)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个参数比较简单直观，不用多说。其实在chrome模拟手机浏览的时候，也有这个参数的，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/4_pc_px.png&quot; alt=&quot;chrome模拟像素比&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中红色框中的就是这个像素比。&lt;/p&gt;

&lt;h4 id=&quot;webkitbackingstorepixelratio&quot;&gt;webkitBackingStorePixelRatio&lt;/h4&gt;

&lt;p&gt;webkitBackingStorePixelRatio是存在canvas context中（仅safari和chrome），该属性的值决定了浏览器在渲染canvas之前会用几个像素来存储画布信息。
例如，在iOS6 safari中这个值为2，它要渲染 100px x 100px 的图片，首先会在内存中生成一张200x200的图片，然后浏览器渲染的时候，会按100x100的图片来渲染，
因此就变成了200x200，正好和内存中的图片大小一致，因此在iOS的safari中不会出现失真的问题（有点绕口，慢慢理解）。&lt;/p&gt;

&lt;p&gt;但是在iOS7 的safari中这个值又变成了1，是出于性能的考虑，详情可以看&lt;a href=&quot;http://asciiwwdc.com/2013/sessions/600&quot;&gt;这里&lt;/a&gt;，搜索关键字‘backing’。&lt;/p&gt;

&lt;p&gt;知道了这俩个参数，那接下来怎么玩？实践是检验真理的唯一标准。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;实践&lt;/h3&gt;

&lt;p&gt;修改之前的代码，把像素比加进去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var PIXEL_RATIO = (function () {
    var ctx = document.createElement(&quot;canvas&quot;).getContext(&quot;2d&quot;),
        dpr = window.devicePixelRatio || 1,
        bsr = ctx.webkitBackingStorePixelRatio ||
              ctx.mozBackingStorePixelRatio ||
              ctx.msBackingStorePixelRatio ||
              ctx.oBackingStorePixelRatio ||
              ctx.backingStorePixelRatio || 1;

    return dpr / bsr;
})();

window.onload = function () {
	var canvas = document.getElementById(&#39;canvas1&#39;);
	var ctx = canvas.getContext(&quot;2d&quot;);
	var width, height;
	width = 320;
	height = 568;

	canvas.style.width = width+&#39;px&#39;;
	canvas.style.height = height + &#39;px&#39;;
	canvas.width = width * PIXEL_RATIO; 
	canvas.height = height * PIXEL_RATIO;
	var img = new Image();
	img.src = &quot;../img/s6_1.png&quot;;
	img.onload = function () {  
	    ctx.drawImage(img, 20, 20, img.width/2, img.height/2); 
	}  
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看看效果（左边为之前效果，右边为修改后效果）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/1_pc.png&quot; alt=&quot;之前&quot; /&gt;
&lt;img src=&quot;/images/2015/20150706canvas/5_pc.png&quot; alt=&quot;之后&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发现了什么？图居然缩小了！我滴天，这是为什么？认真想想问题出在哪里。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;因为CSS像素点被缩放了&lt;/code&gt;，为什么会缩放？因为它是大爷，它想缩所以缩了。&lt;/p&gt;

&lt;p&gt;所以解决方案是对canvas进行缩放，下面是完整版代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var PIXEL_RATIO = (function () {
	    var ctx = document.createElement(&quot;canvas&quot;).getContext(&quot;2d&quot;),
	        dpr = window.devicePixelRatio || 1,
	        bsr = ctx.webkitBackingStorePixelRatio ||
	              ctx.mozBackingStorePixelRatio ||
	              ctx.msBackingStorePixelRatio ||
	              ctx.oBackingStorePixelRatio ||
	              ctx.backingStorePixelRatio || 1;

	    return dpr / bsr;
})();

window.onload = function () {
	var canvas = document.getElementById(&#39;canvas1&#39;);
	var ctx = canvas.getContext(&quot;2d&quot;);
	var width, height;
	width = 320;
	height = 568;

	canvas.style.width = width+&#39;px&#39;;
	canvas.style.height = height + &#39;px&#39;;
	canvas.width = width * PIXEL_RATIO; 
	canvas.height = height * PIXEL_RATIO;

	ctx.scale(PIXEL_RATIO, PIXEL_RATIO);

	var img = new Image();
	img.src = &quot;../img/s6_1.png&quot;;
	img.onload = function () {  
	    ctx.drawImage(img, 20, 20); 
	}  
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;左边是电脑之前模拟的效果，右边是电脑现在模拟的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/1_pc.png&quot; alt=&quot;之前电脑&quot; /&gt;
&lt;img src=&quot;/images/2015/20150706canvas/7_pc.png&quot; alt=&quot;之后电脑&quot; /&gt;&lt;/p&gt;

&lt;p&gt;左边是手机之前的效果，右边是手机现在的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2015/20150706canvas/2_phone.jpg&quot; alt=&quot;之前手机&quot; /&gt;
&lt;img src=&quot;/images/2015/20150706canvas/8_ph.jpg&quot; alt=&quot;之后手机&quot; /&gt;&lt;/p&gt;

&lt;p&gt;嗯，基本的解决方案就是这样。如果有问题，可以提出来～&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/laijingyao881201/article/details/39505043&quot;&gt;http://blog.csdn.net/laijingyao881201/article/details/39505043&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/canvas/hidpi/&quot;&gt;http://www.html5rocks.com/en/tutorials/canvas/hidpi/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>2015展望</title>
   <link href="jeffdeng.me/plan/2015/01/08/plan"/>
   <updated>2015-01-08T00:00:00+08:00</updated>
   <id>jeffdeng.me/plan/2015/01/08/plan</id>
   <content type="html">
&lt;p&gt;TP:008D7BD6&lt;/p&gt;

&lt;p&gt;新的一年，总得写点什么，例如立下些雄心壮志的目标之类。虽然最后往往都是不了了之，但还是可以很装的说一句：立过。&lt;/p&gt;

&lt;p&gt;这一年大目标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;做好毕设项目。&lt;/li&gt;
  &lt;li&gt;多看书。&lt;/li&gt;
  &lt;li&gt;多锻炼。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先说说现在的情况。&lt;/p&gt;

&lt;p&gt;毕设已经开始做，采用的是nodejs+mysql+backbone，基本框架已经搭好。但整个流程还没想好，导致数据库的表也还没建完。4月20多号就要做完（今年真的是变态的早），然后答辩。这样一想，时间还是挺紧迫的。赶紧赶紧~&lt;/p&gt;

&lt;p&gt;虽然时间比较紧，首先还是要把功能想清楚的，把流程划分好模块。然后把表建好。再把基本的框架完善，然后堆业务就好了（想的是不是太简单了）。&lt;/p&gt;

&lt;p&gt;然后说看书的吧。14年基本没怎么看书，技术不升反降。现在工作这么久，又懒的看书，都是够用就好（囧~）。&lt;/p&gt;

&lt;p&gt;好把，今年要看100+本书！咳咳，开玩笑的啦。技术书籍的话，就把已经买了的技术书看完就好了。因为我对技术书籍毫无抵抗力啊，每次看到好书就毫不犹豫的买回来，拿到书时候那个开心啊！但是！买回来居然不看，就放在那里养老。然后又把书架堆的满满的！每次别人看到，都一脸膜拜的样子，搞得我超级不好意思哎，一半我都没看过的啊~搞得每次我都想把书藏好！&lt;/p&gt;

&lt;p&gt;然后非技术的书也要看的，买kindle就是为了看这些书的。反正今年的目标就是：看看看~当然，不能为了看书而看书，该思考的还是得思考，该记录的还是得记录。可不能像完成任务一样刷刷刷。&lt;/p&gt;

&lt;p&gt;再说说技术吧，前端今年肯定是要搞的比较通透了的，毕竟接触前端也有三年了差不多，但现在还是属于无脑编码型。很多东西没有去总结，就一直没有得到应有的提高。懒得要命的毛病，今年得改~然后nodejs也是要学的，虽然也接触了挺久了，但一直在做简单的小demo，还没有深入去学习，加入自己的理解。数据库也得看，操作系统，算法导论，编译原理等等（一想到这么多的大部头，真不知道自己为啥那么高兴的买回来）。总得来说，还是得定下心来，去看书，去实践。&lt;/p&gt;

&lt;p&gt;锻炼的话，多跑步，多爬山。少吃零食，多睡觉。就酱。&lt;/p&gt;

&lt;p&gt;希望到了2016，总结我的2015，是：充实+技术。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>2014年回顾</title>
   <link href="jeffdeng.me/plan/2015/01/04/year-review"/>
   <updated>2015-01-04T00:00:00+08:00</updated>
   <id>jeffdeng.me/plan/2015/01/04/year-review</id>
   <content type="html">
&lt;p&gt;2015年匆匆的赶来了，100秒钟都不多给，好坏的。&lt;/p&gt;

&lt;p&gt;时间过的，一般快。对于过得充实的人来说，时间还好，游刃有余。对于我，
时间就像把我牢牢绑在几百万牛顿推力的火箭上，一路上了拉着我啊啊啊啊的往前冲，或者有时候
还没啊出来，时间就把我带过去了。一回头，发现离原地越来越远。好吧，又扯淡了。&lt;/p&gt;

&lt;p&gt;先看看&lt;a href=&quot;/2014/02/20/plan.html&quot;&gt;14年的计划&lt;/a&gt;，这篇文章是14年2月20号写的。不知不觉写了快一年，感觉就像在昨天，好快啊。又扯淡了，打手！&lt;/p&gt;

&lt;p&gt;14年的计划是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;换mx3，买kindle，买台1500左右的山地车，买台mac pro，去海南环岛。&lt;/li&gt;
    &lt;li&gt;锻炼身体，走百公里。&lt;/li&gt;
    &lt;li&gt;奋斗。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;那一年过去了，哪些实现了？你觉得哪些可以实现？上面说买各种东西说的是用自己赚的钱买的。说这个的时候才大三开学，对前途一片渺茫。我都不知道怎么突然会有这样的想法。当时和我姐说过，我姐轻轻的说，不现实~其实有愿望还是好的，如果最后没有实现，但这个愿望毕竟在一段时间里给过你力量。&lt;/p&gt;

&lt;p&gt;恩，结果是没有买mx3，不过买了mx4，kindle也买了。山地车没有买，也没有去海南环岛（好遗憾）。&lt;s&gt;mac pro 也准备买了，就等等师兄过HK（我没有办通行证啊摔）&lt;/s&gt;最后还是没有买，用着公司的mini。&lt;/p&gt;

&lt;p&gt;然后3月份开始还是有锻炼的，然后去走了传说中百公里。对于我这样虚弱的存在，你觉得走了多少公里呢？什么，至少99公里？恩，我计划也是这样的。然后事实是~~走了40多公里而已，从深圳湾开始一直走到梧桐山。从晚上6点左右出发，一直走到第二天早上7点多。虽然大脑一直在鞭笞我前进前进前进，但腿还是很诚实的啊，牢牢的粘在地上迈不起来，捂脸。&lt;/p&gt;

&lt;p&gt;由于第一次，没经验，走到最后凌晨3、4点的时候真的好累好累，又饿，腿一动就疼，这个时候真的好想家啊！我要妈妈，我要回家！当时真想挂在树上不走了，但又是在偏僻的地方，不走下去没人接啊。只能继续迈着小短腿，扭着小屁股左摇右摆的挪下去。不过，万幸的是脚没有出泡泡，也没有抽筋。然后也没有低血糖的感觉（还是年轻过的，虽然经常低血糖，囧）。&lt;/p&gt;

&lt;p&gt;其实后来想想，还是很害怕的，因为如果有什么突发意外，腿抽筋啊什么的，真的完全没有考虑到。后来那么累，又没有实物补充，要是晕倒怎么办。只能说，不想那么多反而没问题。年轻就是战胜一切的法宝。&lt;/p&gt;

&lt;p&gt;还有就是回来的时候坐公交，超级多人，还要排队，都累趴了还排队？没办法，只能一脸要死的样子像僵尸一样跟在队伍后面。上了公交还要站，好吧，看到外面还在排队的人，我认了。还好到了地铁就有位置了。迷迷糊糊瞌睡了一路~记得当时有个小女孩，用她很好奇的眼睛看着我们打瞌睡的样子，觉得好困惑呢。哈哈~&lt;/p&gt;

&lt;p&gt;然后暑假到现在，基本是没什么运动了。自从实习了，肚腩也越发嚣张！摔摔摔！&lt;/p&gt;

&lt;p&gt;然后就考完试就到暑假啦，啦啦啦~终于不用上课了。最重要的是，这个学期不仅把挂的课修回来，还没有挂科。对于每个学期必挂一科的我，真的很难得。&lt;/p&gt;

&lt;p&gt;然后就出去找实习了。恩，还不错，之前有个来学校校招，招应届毕业生做H5的，但我凭借出色的人格魅力征服了他们，最后还是同意让我去实习（其实面试得一塌糊涂）。但由于公司和我预期有点出入，最后还是没有去。&lt;/p&gt;

&lt;p&gt;然后去了另外一家创业公司。去这家公司真的很巧合，因为我是在技术论坛上找的。那个时候，我还年轻，经常逛技术论坛，哦，看的最多的是当然八卦事情。然后加入了个技术QQ群，然后公司的老板在里面招人，我就顺理成章的进来了。后来，做了一个半月，到8月31号，公司资金撑不住了，终于要倒闭了。好伤感，那一瞬~后来大家一起看了个《分手大师》，吃了顿饭就说拜拜了。伤感~还是珍惜现在和你一起奋斗的人吧，说不定什么时候就说拜拜了。&lt;/p&gt;

&lt;p&gt;没了工作，就在宿舍宅了十几天。专心做全宇宙最宅的宅男。因为8月尾的时候，做了阿里的网上测试，通知过广州面试。但觉得自己技术一般般，又懒的过去就拒了。这个时候应该有点伤感。&lt;/p&gt;

&lt;p&gt;后来，前公司同事把我叫到了现在这家新的创业公司。又开始每天coding的生活啦~&lt;/p&gt;

&lt;p&gt;恩。国庆的时候，回去拜山。在山上，砍掉杂草的时候，由于早餐没吃饱，运动过快，血糖供应不上，一头栽到地上，断片了。人生第一次断片哦，超激动，原来真有断片~说这个，只是想说经常低血糖的要时刻关注自己身体的情况。发现不对，马上蹲下来。管他那么多，蹲蹲蹲。&lt;/p&gt;

&lt;p&gt;然后12月末的时候，和以前实验室的童鞋去了惠东玩了两天一夜。不用花钱哦~好把，是别人团购多出来的位置，让我占便宜了。哈哈~感觉惠东的海好漂亮哦。那个双月湾真的很不错哦。不过其他地方就一般般了。去的第二天好像是妈祖出海庆典，好像是60年一次。好把，远远眺望了几眼就走了~&lt;/p&gt;

&lt;p&gt;这一年，基本没看什么书（惭愧，摔摔摔）。
下面是看过的(我都有实体书)：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;活法 稻盛和夫&lt;/li&gt;
  &lt;li&gt;因为疼痛所以叫青春&lt;/li&gt;
  &lt;li&gt;1988我想和这个世界谈谈&lt;/li&gt;
  &lt;li&gt;这些道理没人告诉你&lt;/li&gt;
  &lt;li&gt;浪潮之巅&lt;/li&gt;
  &lt;li&gt;形式感 网页视觉设计创意拓展与快速表现&lt;/li&gt;
  &lt;li&gt;设计师要懂心理学&lt;/li&gt;
  &lt;li&gt;超越平凡的平面设计 版式设计原理与应用&lt;/li&gt;
  &lt;li&gt;Nodejs开发指南&lt;/li&gt;
  &lt;li&gt;深入浅出Nodejs&lt;/li&gt;
  &lt;li&gt;MongoDB权威指南&lt;/li&gt;
  &lt;li&gt;javascript编程精解&lt;/li&gt;
  &lt;li&gt;精彩绝伦的css&lt;/li&gt;
  &lt;li&gt;HTML5程序设计&lt;/li&gt;
  &lt;li&gt;疯狂Android讲义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他还有一些就忘记了，借图书馆的书，还了就忘记了（这记忆力，是病，得治）。上面这些也很多忘记了。想想都好惭愧，一年这么久居然就看这么几本书~&lt;/p&gt;

&lt;p&gt;当然，还看了好多好多无聊的小说，上课无聊嘛，总要消磨时间（是不是暴露什么了）。&lt;/p&gt;

&lt;p&gt;总的来说，2014，挺好。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>java的urlrewritefilter简单使用</title>
   <link href="jeffdeng.me/java/2014/12/12/java-urlrewritefilter"/>
   <updated>2014-12-12T00:00:00+08:00</updated>
   <id>jeffdeng.me/java/2014/12/12/java-urlrewritefilter</id>
   <content type="html">
&lt;p&gt;由于项目中只用了&lt;code&gt;tomcat&lt;/code&gt;，没有用&lt;code&gt;Apache&lt;/code&gt;，然后想做&lt;code&gt;www&lt;/code&gt;重定向。就如让所有访问&lt;code&gt;baidu.com&lt;/code&gt;都301永久重定向到&lt;code&gt;www.baidu.com&lt;/code&gt;。然后时间紧急，对&lt;code&gt;Apache&lt;/code&gt;不是很熟悉（懒的去配置），就直接用了&lt;code&gt;java&lt;/code&gt;的一个包：
&lt;code&gt;urlrewritefilter&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;官网是：&lt;a href=&quot;http://tuckey.org/urlrewrite/&quot;&gt;http://tuckey.org/urlrewrite/&lt;/a&gt;。使用方法也很简单，这里简单说下。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1.下载&lt;/h3&gt;
&lt;p&gt;先去下载&lt;code&gt;urlrewritefilter-x.x.x.jar &lt;/code&gt;包。下载好放到&lt;code&gt;WEB-INF/lib&lt;/code&gt;目录下。&lt;/p&gt;

&lt;h3 id=&quot;webxml&quot;&gt;2.配置web.xml&lt;/h3&gt;
&lt;p&gt;修改web.xml，把下面代码放到所有servlet mappings的前面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;UrlRewriteFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.tuckey.web.filters.urlrewrite.UrlRewriteFilter&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;UrlRewriteFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
    &amp;lt;dispatcher&amp;gt;REQUEST&amp;lt;/dispatcher&amp;gt;
    &amp;lt;dispatcher&amp;gt;FORWARD&amp;lt;/dispatcher&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是对应的参数文档 &lt;a href=&quot;http://urlrewritefilter.googlecode.com/svn/trunk/src/doc/manual/4.0/index.html#filterparams&quot;&gt;filterparams&lt;/a&gt;。这就配置完了（这里有个很坑爹的问题，待会说）。&lt;/p&gt;

&lt;h3 id=&quot;urlrewritexml&quot;&gt;3.增加 &lt;code&gt;urlrewrite.xml&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;然后在 &lt;code&gt;WEB-INF&lt;/code&gt; 文件夹里增加多 &lt;code&gt;urlrewrite.xml&lt;/code&gt; 文件。&lt;/p&gt;

&lt;p&gt;下面是官方标准urlrewrite.xml文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE urlrewrite PUBLIC &quot;-//tuckey.org//DTD UrlRewrite 4.0//EN&quot;
        &quot;http://www.tuckey.org/res/dtds/urlrewrite4.0.dtd&quot;&amp;gt;

&amp;lt;!--

    Configuration file for UrlRewriteFilter
    http://www.tuckey.org/urlrewrite/

--&amp;gt;
&amp;lt;urlrewrite&amp;gt;

    &amp;lt;rule&amp;gt;
        &amp;lt;note&amp;gt;
            The rule means that requests to /test/status/ will be redirected to /rewrite-status
            the url will be rewritten.
        &amp;lt;/note&amp;gt;
        &amp;lt;from&amp;gt;/test/status/&amp;lt;/from&amp;gt;
        &amp;lt;to type=&quot;redirect&quot;&amp;gt;%{context-path}/rewrite-status&amp;lt;/to&amp;gt;
    &amp;lt;/rule&amp;gt;


    &amp;lt;outbound-rule&amp;gt;
        &amp;lt;note&amp;gt;
            The outbound-rule specifies that when response.encodeURL is called (if you are using JSTL c:url)
            the url /rewrite-status will be rewritten to /test/status/.

            The above rule and this outbound-rule means that end users should never see the
            url /rewrite-status only /test/status/ both in thier location bar and in hyperlinks
            in your pages.
        &amp;lt;/note&amp;gt;
        &amp;lt;from&amp;gt;/rewrite-status&amp;lt;/from&amp;gt;
        &amp;lt;to&amp;gt;/test/status/&amp;lt;/to&amp;gt;
    &amp;lt;/outbound-rule&amp;gt;


    &amp;lt;!--

    INSTALLATION

        in your web.xml add...

        &amp;lt;filter&amp;gt;
            &amp;lt;filter-name&amp;gt;UrlRewriteFilter&amp;lt;/filter-name&amp;gt;
            &amp;lt;filter-class&amp;gt;org.tuckey.web.filters.urlrewrite.UrlRewriteFilter&amp;lt;/filter-class&amp;gt;
            &amp;lt;init-param&amp;gt;
                &amp;lt;param-name&amp;gt;logLevel&amp;lt;/param-name&amp;gt;
                &amp;lt;param-value&amp;gt;WARN&amp;lt;/param-value&amp;gt;
            &amp;lt;/init-param&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;filter-mapping&amp;gt;
            &amp;lt;filter-name&amp;gt;UrlRewriteFilter&amp;lt;/filter-name&amp;gt;
            &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
        &amp;lt;/filter-mapping&amp;gt;

     EXAMPLES

     Redirect one url
        &amp;lt;rule&amp;gt;
            &amp;lt;from&amp;gt;/some/old/page.html&amp;lt;/from&amp;gt;
            &amp;lt;to type=&quot;redirect&quot;&amp;gt;/very/new/page.html&amp;lt;/to&amp;gt;
        &amp;lt;/rule&amp;gt;

    Redirect a directory
        &amp;lt;rule&amp;gt;
            &amp;lt;from&amp;gt;/some/olddir/(.*)&amp;lt;/from&amp;gt;
            &amp;lt;to type=&quot;redirect&quot;&amp;gt;/very/newdir/$1&amp;lt;/to&amp;gt;
        &amp;lt;/rule&amp;gt;

    Clean a url
        &amp;lt;rule&amp;gt;
            &amp;lt;from&amp;gt;/products/([0-9]+)&amp;lt;/from&amp;gt;
            &amp;lt;to&amp;gt;/products/index.jsp?product_id=$1&amp;lt;/to&amp;gt;
        &amp;lt;/rule&amp;gt;
    eg, /products/1234 will be passed on to /products/index.jsp?product_id=1234 without the user noticing.

    Browser detection
        &amp;lt;rule&amp;gt;
            &amp;lt;condition name=&quot;user-agent&quot;&amp;gt;Mozilla/[1-4]&amp;lt;/condition&amp;gt;
            &amp;lt;from&amp;gt;/some/page.html&amp;lt;/from&amp;gt;
            &amp;lt;to&amp;gt;/some/page-for-old-browsers.html&amp;lt;/to&amp;gt;
        &amp;lt;/rule&amp;gt;
    eg, will pass the request for /some/page.html on to /some/page-for-old-browsers.html only for older
    browsers whose user agent srtings match Mozilla/1, Mozilla/2, Mozilla/3 or Mozilla/4.

    Centralised browser detection
        &amp;lt;rule&amp;gt;
            &amp;lt;condition name=&quot;user-agent&quot;&amp;gt;Mozilla/[1-4]&amp;lt;/condition&amp;gt;
            &amp;lt;set type=&quot;request&quot; name=&quot;browser&quot;&amp;gt;moz&amp;lt;/set&amp;gt;
        &amp;lt;/rule&amp;gt;
    eg, all requests will be checked against the condition and if matched
    request.setAttribute(&quot;browser&quot;, &quot;moz&quot;) will be called.

    --&amp;gt;

&amp;lt;/urlrewrite&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们经常用到的就两个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; //重定向 地址栏显示的是实际地址
    &amp;lt;rule&amp;gt;
        &amp;lt;from&amp;gt;/some/olddir/(.*)&amp;lt;/from&amp;gt;
        &amp;lt;to type=&quot;redirect&quot;&amp;gt;/very/newdir/$1&amp;lt;/to&amp;gt;
    &amp;lt;/rule&amp;gt;

//转发 地址了显示的是虚拟地址
    &amp;lt;rule&amp;gt;
        &amp;lt;from&amp;gt;/products/([0-9]+)&amp;lt;/from&amp;gt;
        &amp;lt;to&amp;gt;/products/index.jsp?product_id=$1&amp;lt;/to&amp;gt;
    &amp;lt;/rule&amp;gt;
eg, /products/1234 will be passed on to /products/index.jsp?product_id=1234 without the user noticing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配的是java的正则表达式。&lt;/p&gt;

&lt;h3 id=&quot;www301&quot;&gt;4.www301重定向&lt;/h3&gt;
&lt;p&gt;下面就是我要用到的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//如果地址的域名不是 www.baidu.com 就会跳转到www.baidu.com
//为了考虑开发情况，把 localhost 也加到里面
&amp;lt;rule&amp;gt;
    &amp;lt;name&amp;gt;seo redirect&amp;lt;/name&amp;gt;
    &amp;lt;condition name=&quot;host&quot; operator=&quot;notequal&quot;&amp;gt;^www.baidu.com&amp;lt;/condition&amp;gt;
    &amp;lt;condition name=&quot;host&quot; operator=&quot;notequal&quot;&amp;gt;^localhost&amp;lt;/condition&amp;gt;
    &amp;lt;from&amp;gt;^/(.*)&amp;lt;/from&amp;gt;
    &amp;lt;to type=&quot;permanent-redirect&quot; last=&quot;true&quot;&amp;gt;http://www.baidu.com/$1&amp;lt;/to&amp;gt;
&amp;lt;/rule&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里为止，一切都正常。但是我用转发却不行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;rule&amp;gt;
    &amp;lt;from&amp;gt;/products/([0-9]+)&amp;lt;/from&amp;gt;
    &amp;lt;to&amp;gt;/products/index.jsp?product_id=$1&amp;lt;/to&amp;gt;
&amp;lt;/rule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问&lt;code&gt;localhost:8080/products/123&lt;/code&gt;一直报&lt;code&gt;404&lt;/code&gt;，而且还是乱码。&lt;/p&gt;

&lt;p&gt;这个问题纠结了好久。&lt;code&gt;api&lt;/code&gt;里也没看到哪里出问题了。最后，终于发现，是转发后被&lt;code&gt;struts&lt;/code&gt;拦截了。所以，要修改&lt;code&gt;web.xml&lt;/code&gt;。在&lt;code&gt;struts2&lt;/code&gt;的&lt;code&gt;&amp;lt;filter-mapping&amp;gt;&lt;/code&gt;里加上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;dispatcher&amp;gt;REQUEST&amp;lt;/dispatcher&amp;gt;  
&amp;lt;dispatcher&amp;gt;FORWARD&amp;lt;/dispatcher&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以了。浪费好多时间去弄这个问题，囧~&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://xlaohe1.iteye.com/blog/1130854&quot;&gt;http://xlaohe1.iteye.com/blog/1130854&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://fanzhongyun.iteye.com/blog/1221170&quot;&gt;http://fanzhongyun.iteye.com/blog/1221170&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/ygf215/article/details/4766285&quot;&gt;http://blog.csdn.net/ygf215/article/details/4766285&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nematodes.org/martin/2010/02/04/301-permanent-redirect-with-tomcat-howto/&quot;&gt;http://nematodes.org/martin/2010/02/04/301-permanent-redirect-with-tomcat-howto/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>译.css选择器渲染优化</title>
   <link href="jeffdeng.me/css/2014/12/08/css-selector"/>
   <updated>2014-12-08T00:00:00+08:00</updated>
   <id>jeffdeng.me/css/2014/12/08/css-selector</id>
   <content type="html">
&lt;p&gt;原文：&lt;a href=&quot;http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/&quot;&gt;css selector performance has changed&lt;/a&gt;。这里来看看这篇文章的主要内容。&lt;/p&gt;

&lt;p&gt;下面是我们之前就知道的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;选择器匹配元素是从右到左，应该避免比较艰难匹配的选择器。&lt;/li&gt;
  &lt;li&gt;后代选择器是比较缓慢的，尤其是最右的选择器匹配到大量元素的时候。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改变的现状：&lt;/p&gt;

&lt;p&gt;Antti Koivisto，是&lt;code&gt;WebKit&lt;/code&gt;代码的贡献者，最近花了一些时间去优化&lt;code&gt;css&lt;/code&gt;的选择器匹配。在完成这项工作后，他说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我的观点是：写代码的人不应该去担心选择器的优化，这应该是浏览器引擎的工作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面我们来看看他在四个方面做的特别优化：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Style Sharing（共享样式）&lt;/li&gt;
  &lt;li&gt;Rule Hashes（哈希规则）&lt;/li&gt;
  &lt;li&gt;Ancestor Filters（父代过滤器）&lt;/li&gt;
  &lt;li&gt;Fast Path（快速路径）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section&quot;&gt;&lt;strong&gt;共享样式&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;共享样式允许浏览器根据已经匹配到得元素，快速找出其他相同样式的元素。&lt;/p&gt;

&lt;p&gt;ex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
  &amp;lt;p&amp;gt;foo&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;bar&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果浏览器引擎已经计算出第一个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;的样式（已经渲染），它就不用再去计算第二个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;的样式，直接渲染就是了（当然这个前提是第一个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;和第二个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;的样式选择器一致，如&lt;code&gt;div p{}
&lt;/code&gt;之类）。这是很简单的一小步，却优化
选择器的一大步。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;哈希规则&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们现在都知道匹配选择器是从右到左，所以最右边的选择器是很重要的。哈希规则基于最右的选择器来把选择器分组。举个例子，下面的选择器会分成三组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a {}
div p {}
div p.legal {}
#sidebar a {}
#sidebar p {}

1: a, a {}, #sidebar a

2: p, div p {}, #sidebar p {}

3: p.legal , div p.legal {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当浏览器使用哈希规则的时候，它不一定要去查找样式表中所个有的单的选择器，而是分组去匹配。
这对于页面上单个的&lt;code&gt;HTML&lt;/code&gt;元素，同样很巧妙的节省了很多工作。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;父代过滤器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;父代过滤器是有点复杂的。它们通过计算一个选择器可以匹配的可能性，去过滤，所以也称为可能性过滤器。所以，父代过滤器可以快速排除那些没有匹配的元素。它通过&lt;code&gt;class&lt;/code&gt;,&lt;code&gt;id&lt;/code&gt;,&lt;code&gt;tag&lt;/code&gt;去匹配后代和子选择器。后代选择器是认为匹配比较慢的，因为渲染引擎要循环所有的父节点，尝试选择器是否匹配。这个时候&lt;code&gt;bloom&lt;/code&gt;过滤器就闪亮登场了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bloom&lt;/code&gt;过滤器是一个数据集合，可以让你判断某个选择器是否在集合中.bloom过滤器判断一个
css规则是否是在当前的元素集合中（The bloom filter tests whether a CSS rule is a member of the set of rules which match the element you are currently testing）。这其中很特别的一件事是，误报是有可能的，但漏报是不可能的。这意味着，如果bloom过滤器判断出一个选择器不符合当前的元素，浏览器就会停止查看当前的选择器，跳到下一个选择器。这里又节省了很多时间。如果&lt;code&gt;bloom&lt;/code&gt;过滤器判断出当前的元素匹配，浏览器会继续通过常规的方法去进行100%的准确匹配。样式表文件越大，误报的几率就越大。所以要保持样式表文件的比较近小。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;&lt;strong&gt;快速路径&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;快速路径通过内在的循环，而不是递归，去取代常规的匹配逻辑（Fast path re-implements more general matching logic using a non-recursive, fully inlined loop. ）。 它通常用在匹配下面组合的选择器：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;后代，子代，子代选择器组合&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;tag&lt;/code&gt;，&lt;code&gt;id&lt;/code&gt;，&lt;code&gt;class&lt;/code&gt;和属性组合选择器&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上就是Antti对&lt;code&gt;WebKit&lt;/code&gt;引擎的四个优化。(有点高深，不是很懂~囧)&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>译.css性能</title>
   <link href="jeffdeng.me/css/2014/12/08/css-performance"/>
   <updated>2014-12-08T00:00:00+08:00</updated>
   <id>jeffdeng.me/css/2014/12/08/css-performance</id>
   <content type="html">
&lt;p&gt;原文：&lt;a href=&quot;https://dl.dropboxusercontent.com/u/39519/talks/cssperf/index.html&quot;&gt;CSS Performance&lt;/a&gt;（2011年文章，有着很赞的翻转效果，前提是祭出高级浏览器）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Reflows（重排）&lt;/li&gt;
  &lt;li&gt;Hardware Accelerated Css（硬件加速css）&lt;/li&gt;
  &lt;li&gt;Avoiding Expensive Css（避免高消耗css）&lt;/li&gt;
  &lt;li&gt;Selector Perf（选择器性能）&lt;/li&gt;
  &lt;li&gt;Style Matching Perf（样式匹配性能）&lt;/li&gt;
  &lt;li&gt;Polyfills&lt;/li&gt;
  &lt;li&gt;Debugging（调试）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;&lt;strong&gt;1. 重排&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;先来看看html页面的渲染、绘制流程图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2014/css_performance/render.png&quot; alt=&quot;render&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据&lt;code&gt;Html&lt;/code&gt;标签生成&lt;code&gt;Dom&lt;/code&gt;树（&lt;code&gt;Dom tree&lt;/code&gt;）；根据默认的，用户自定义的样式生成样式结构（&lt;code&gt;Styles struct&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;生成渲染树（&lt;code&gt;Render tree&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;绘制页面&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面是重排的渲染短视频：&lt;/p&gt;

&lt;video controls=&quot;&quot; preload=&quot;&quot; autobuffer=&quot;&quot; width=&quot;860&quot; height=&quot;510&quot;&gt;
	&lt;source src=&quot;https://dl.dropboxusercontent.com/u/39519/talks/cssperf/assets/geckoreflow-mozillaorg.mp4&quot; type=&quot;video/mp4&quot; /&gt;
	&lt;source src=&quot;https://dl.dropboxusercontent.com/u/39519/talks/cssperf/assets/geckoreflow-mozillaorg.webm&quot; type=&quot;video/webm&quot; /&gt;
&lt;/video&gt;

&lt;p&gt;下面，先看看重绘机制：如何（不）触发&lt;code&gt;WebKit&lt;/code&gt;的布局（&lt;a href=&quot;http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html&quot;&gt;How (not) to trigger a layout in WebKit&lt;/a&gt;）（2011）。&lt;/p&gt;

&lt;p&gt;简单译文：&lt;/p&gt;

&lt;p&gt;许多&lt;code&gt;Web&lt;/code&gt;开发者意识到，一段&lt;code&gt;js&lt;/code&gt;脚本在运行的时候，是在触发&lt;code&gt;DOM&lt;/code&gt;的操作而不是执行代码本身。这样一个潜在消耗时间，从&lt;code&gt;Dom&lt;/code&gt;树构建渲染树（&lt;code&gt;Render tree&lt;/code&gt;）的过程，被称作布局（又称重排）。约庞大越复杂的&lt;code&gt;Dom&lt;/code&gt;树，就会消耗更多的时间。&lt;/p&gt;

&lt;p&gt;一个很重要的方法让页面的不假死，就是让分开的Dom操作放在一起。&lt;/p&gt;

&lt;p&gt;ex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 一般，触发两次布局
var newWidth = aDiv.offsetWidth + 10; // Read
aDiv.style.width = newWidth + &#39;px&#39;; // Write
var newHeight = aDiv.offsetHeight + 10; // Read
aDiv.style.height = newHeight + &#39;px&#39;; // Write

// 更好, 只触发一次布局
var newWidth = aDiv.offsetWidth + 10; // Read
var newHeight = aDiv.offsetHeight + 10; // Read
aDiv.style.width = newWidth + &#39;px&#39;; // Write
aDiv.style.height = newHeight + &#39;px&#39;; // Write
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后这里就会有个问题：什么情况会触发布局？下面是整理的一些元素和方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Element
clientHeight, clientLeft, clientTop, clientWidth, focus(), getBoundingClientRect(), getClientRects(), innerText, offsetHeight, offsetLeft, offsetParent, offsetTop, offsetWidth, outerText, scrollByLines(), scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(), scrollLeft, scrollTop, scrollWidth

Frame, Image
height, width

Range
getBoundingClientRect(), getClientRects()

SVGLocatable
computeCTM(), getBBox()

SVGTextContent
getCharNumAtPosition(), getComputedTextLength(), getEndPositionOfChar(), getExtentOfChar(), getNumberOfChars(), getRotationOfChar(), getStartPositionOfChar(), getSubStringLength(), selectSubString()

SVGUse
instanceRoot

window
getComputedStyle(), scrollBy(), scrollTo(), scrollX, scrollY, webkitConvertPointFromNodeToPage(), webkitConvertPointFromPageToNode()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然列出的这些不是全部，这只是一个很好的开始。最好的方法是通过Chrome或者Firefox浏览器的调试器去查看。（翻译完）&lt;/p&gt;

&lt;p&gt;好的，再回到这里，我们看看什么动作会触发重排。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;增加，删除，更新&lt;code&gt;Dom&lt;/code&gt;节点。&lt;/li&gt;
  &lt;li&gt;通过&lt;code&gt;display:none&lt;/code&gt;隐藏元素。&lt;/li&gt;
  &lt;li&gt;对页面上的&lt;code&gt;Dom&lt;/code&gt;元素进行移动等动画。&lt;/li&gt;
  &lt;li&gt;增加样式，或调整样式属性。&lt;/li&gt;
  &lt;li&gt;用户改变窗口大小，改变字体大小，或者滚动页面。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;策略：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在触发重排动作前，对&lt;code&gt;Dom&lt;/code&gt;进行批量操作。&lt;/li&gt;
  &lt;li&gt;复制节点的属性，在复制的节点里进行操作，在一次交换过来。&lt;/li&gt;
  &lt;li&gt;先用&lt;code&gt;display:none&lt;/code&gt;隐藏节点，再进行大量的操作，再通过&lt;code&gt;display&lt;/code&gt;显示。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多重排文章：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/&quot;&gt;Stoyan Stefanov on Reflow/Repaint&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://calendar.perfplanet.com/2009/the-new-game-show-will-it-reflow/&quot;&gt;The new game show: “Will it reflow?”&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.browserscope.org/?category=reflow&quot;&gt;Mozilla’s David Baron on Browser Internals for Web Developers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=a2_6bGNZ7bA&quot;&gt;WebKit blog five-part series on rendering&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;css&quot;&gt;&lt;strong&gt;2.硬件加速css&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;充分利用&lt;code&gt;Css&lt;/code&gt;的&lt;code&gt;transitions&lt;/code&gt;和&lt;code&gt;transforms&lt;/code&gt;达到最优的质量。
这方面主要应用于手机，ios和Android&lt;/p&gt;

&lt;video controls=&quot;&quot; preload=&quot;&quot; autobuffer=&quot;&quot; width=&quot;860&quot; height=&quot;310&quot;&gt;
	&lt;source src=&quot;https://dl.dropboxusercontent.com/u/39519/talks/cssperf/assets/translate3d.mp4&quot; type=&quot;video/mp4&quot; /&gt;
	&lt;source src=&quot;https://dl.dropboxusercontent.com/u/39519/talks/cssperf/assets/translate3d.webm&quot; type=&quot;video/webm&quot; /&gt;
&lt;/video&gt;

&lt;h2 id=&quot;css-1&quot;&gt;&lt;strong&gt;3.避免高消耗css&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;@font-face&lt;/li&gt;
  &lt;li&gt;box-shadow&lt;/li&gt;
  &lt;li&gt;opacity compositing&lt;/li&gt;
  &lt;li&gt;gradients&lt;/li&gt;
  &lt;li&gt;text-align&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(这部分待续…)&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;&lt;strong&gt;4.选择器性能&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;浏览器默认是从右到左。&lt;/p&gt;

&lt;p&gt;下面选择器引擎是从左到右：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mootools&lt;/li&gt;
  &lt;li&gt;Sly&lt;/li&gt;
  &lt;li&gt;Peppy&lt;/li&gt;
  &lt;li&gt;Dojo Acme&lt;/li&gt;
  &lt;li&gt;Ext JS&lt;/li&gt;
  &lt;li&gt;Prototype.js&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是从右到左：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sizzle&lt;/li&gt;
  &lt;li&gt;YUI 3&lt;/li&gt;
  &lt;li&gt;NWMatcher&lt;/li&gt;
  &lt;li&gt;querySelectorAll&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;选择器优化&lt;/p&gt;

&lt;p&gt;推荐组合是：&lt;code&gt;tag .class&lt;/code&gt;，让标签在左边，尽可能让class在右边。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;&lt;strong&gt;5.样式匹配性能&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;关于样式匹配，请看&lt;a href=&quot;http://screwlewse.com/2010/08/different-css-techniques-and-their-performance/&quot;&gt;样式匹配性能&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;polyfills&quot;&gt;&lt;strong&gt;6.Polyfills&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;关于Polyfills的介绍：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Polyfilling 是由 RemySharp 提出的一个术语，它是用来描述复制缺少的 API 和API 功能的行为。你可以使用它编写单独应用的代码而不用担心其他浏览器原生是不是支持。实际上，polyfills并不是新技术也不是和 HTML5 捆绑到一起的。我们已经在如json2.js，ie7-js 和为 IE 浏览器提供透明 PNG支持的JS中使用过了。而和现在 polyfills 的区别就是去年增加的 HTML5 polyfills。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相关信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://selectivizr.com/&quot;&gt;Selectivizr&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://css3pie.com/&quot;&gt;CSS3Pie&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills&quot;&gt;Modernizr wiki list of polyfills&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;&lt;strong&gt;7.调试&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;主要是手机硬件方面的调试。
相关信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://peter.sh/experiments/chromium-command-line-switches/&quot;&gt;All of Chrome’s command line switches&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://mir.aculo.us/2011/02/08/visualizing-webkits-hardware-acceleration/&quot;&gt;Thomas Fuchs: Safari and iPhone Simulator CoreAnimation debugging info.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.html5rocks.com/en/tutorials/speed/html5/&quot;&gt;HTML5Rocks: Improving the Performance of your HTML5 App&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>译.层叠和选择器的明确度--权重</title>
   <link href="jeffdeng.me/css/2014/12/05/css-specificity-wars"/>
   <updated>2014-12-05T00:00:00+08:00</updated>
   <id>jeffdeng.me/css/2014/12/05/css-specificity-wars</id>
   <content type="html">
&lt;p&gt;这是2005年的文章，内容已经比较老，看看就好。&lt;/p&gt;

&lt;p&gt;在css编码规范中提到：&lt;a href=&quot;http://www.stuffandnonsense.co.uk/archives/css_specificity_wars.html&quot;&gt;层叠和选择器的明确度&lt;/a&gt;，翻译了一下主要的内容，不过建议还是去看原版。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;关于原作者
Andy Clarke，是一个英国的的设计师，作者，同时是在设计，css和web accessibility方面具有很大热情的演说家。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;整篇文章主要说权重的问题，下面是大家对权重的常规理解：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;id&lt;/code&gt;选择器的权重是 100&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;class&lt;/code&gt;选择器的权重是 10&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;HTML&lt;/code&gt;选择器的权重为 1&lt;/li&gt;
  &lt;li&gt;选择器的权重就是对应数字加起来&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后下面是W3C对权重的解析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;计算选择器中的&lt;code&gt;id&lt;/code&gt;数量（=a）&lt;/li&gt;
  &lt;li&gt;计算选择器中属性和&lt;code&gt;class&lt;/code&gt;的数量（=b）&lt;/li&gt;
  &lt;li&gt;计算选择器中元素的数量（=c）&lt;/li&gt;
  &lt;li&gt;然后把这些数字按a-b-c连起来，abc就是这个选择器的权重&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后下面是作者的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;元素选择器权重 0，0，1&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;class&lt;/code&gt;选择器权重 0，1，0&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;id&lt;/code&gt;选择器权重 1，0，0&lt;/li&gt;
  &lt;li&gt;然后把对应选择器的数字按对应的位置加起来就是权重&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;感觉3种方法都差不多，只要能正确判断，哪一种都可以。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>express的诡异错误</title>
   <link href="jeffdeng.me/nodejs/2014/12/03/express-fail"/>
   <updated>2014-12-03T00:00:00+08:00</updated>
   <id>jeffdeng.me/nodejs/2014/12/03/express-fail</id>
   <content type="html">
&lt;p&gt;最近用 &lt;code&gt;express&lt;/code&gt; 新建项目，发现一个很诡异的问题，出现的简直毫无理由。我的exprss 版本是&lt;code&gt;4.9.0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;先看 &lt;code&gt;express&lt;/code&gt; 的参数使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;express -h

Usage: express [options] [dir]

Options:

-h, --help          output usage information
-V, --version       output the version number
-e, --ejs           add ejs engine support (defaults to jade)
    --hbs           add handlebars engine support
-H, --hogan         add hogan.js engine support
-c, --css &amp;lt;engine&amp;gt;  add stylesheet &amp;lt;engine&amp;gt; support (less|stylus|compass) (defaults to plain css)
-f, --force         force on non-empty directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建项目，用 &lt;code&gt;ejs&lt;/code&gt; 和 &lt;code&gt;sass&lt;/code&gt; 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;express -e -c compass test

create : test
create : test/package.json
create : test/app.js
create : test/public
create : test/public/javascripts
create : test/public/images
create : test/public/stylesheets
create : test/public/stylesheets/style.scss
create : test/routes
create : test/routes/index.js
create : test/routes/users.js
create : test/views
create : test/views/index.ejs
create : test/views/error.ejs
create : test/bin
create : test/bin/www

install dependencies:
  $ cd test &amp;amp;&amp;amp; npm install

run the app:
  $ DEBUG=test ./bin/www
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;npm install&lt;/code&gt; 后，执行 &lt;code&gt;DEBUG=test ./bin/www&lt;/code&gt; ,现在还是ok的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; test Express server listening on port 3000 +0ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后用浏览器打开 &lt;code&gt;http://localhost:3000/&lt;/code&gt;, 问题来了：&lt;/p&gt;

&lt;p&gt;首先是浏览器报错：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2014/express_fail/20141203-1.png&quot; alt=&quot;chrome-err&quot; /&gt;&lt;/p&gt;

&lt;p&gt;错误信息是：&lt;code&gt;(failed) net::ERR_CONNECTION_REFUSED&lt;/code&gt; ，其实应该报404错误，因为没有这个样式文件。然后这个时候，控制台也会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  test Express server listening on port 3000 +0ms
GET / 200 77.090 ms - 207

events.js:72
        throw er; // Unhandled &#39;error&#39; event
              ^
Error: spawn ENOENT
    at errnoException (child_process.js:1001:11)
    at Process.ChildProcess._handle.onexit (child_process.js:792:34)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键是我只是初始化了项目，代码完全没有改过。&lt;/p&gt;

&lt;p&gt;其实问题出在 &lt;code&gt;node-compass&lt;/code&gt; 模块,可以查看github上的用法说明 &lt;a href=&quot;https://github.com/nathggns/node-compass&quot;&gt;node-compass&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;node-compass requires the compass ruby gem in order to compile compass.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先你的项目要安装ruby， 然后安装 compass。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem update --system
$ gem install compass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好吧，其实是小问题，只是没想通。囧~&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>2014年目标，计划</title>
   <link href="jeffdeng.me/plan/2014/02/20/plan"/>
   <updated>2014-02-20T00:00:00+08:00</updated>
   <id>jeffdeng.me/plan/2014/02/20/plan</id>
   <content type="html">
&lt;blockquote&gt;
  &lt;p&gt;注：原文发布于豆瓣上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前言：之前文章一直发在技术blog，不过最近非技术文章比较多，发了几篇觉得发不下去了。所以就来了豆瓣。都是生活中琐碎的事，看了就忘了吧。&lt;/p&gt;

&lt;p&gt;原来一个人的目标真的会随着时间的推进而改变，而且周期还是，如此快。&lt;/p&gt;

&lt;p&gt;新年时，我的愿望是，或者目标是：换mx3，买kindle，买台1500左右的山地车，买台mac pro，去海南环岛。我不知道怎样的才算是愿望，或者是一瞬间的想法，又或者是蓄谋已久的意向。上面这些应该都是一瞬间的吧，因为在这一瞬间，对上面那些的欲望，说真的，不是很强。&lt;/p&gt;

&lt;p&gt;好吧，那新的愿望或者计划是什么呢。&lt;/p&gt;

&lt;p&gt;让我先酝酿下。好像，我一生还没有奋斗过，为着某个目标。高一时英语课听写单词，每组一个代表，而我，就是我们组的代表。原谅我那惨不忍睹的记忆力，我一个都没写出来，导致最直接的结果是，我们组输了。恩，然后全组人一起唱了首歌。下课后，同桌A在那里抱怨，你怎么这么差劲！搞的我们组输了，还要被罚唱歌。哦，原来我和A同桌过，如果不是因为这件事我还不记得呢。然后我沉默不语。这时坐我前面的语代，一个很萝莉的女生为我打抱不平说，其实我也很努力了，不要怪他。有句话说的很对，自己的情况自己最清楚。我当时是懒得记单词，所以才一个都没写出来。有人为我打抱不平真的让我羞愧不已。然后暗自下决心，我一定要认真学好英语！事实证明，我第二天又恢复原样了。因为，我睡了一觉。一般我睡了一觉很多东西都选择性遗忘。&lt;/p&gt;

&lt;p&gt;高三时，补课，上化学课。当时代课老师是号称学校四大恶人之一的阿蔡。当然，之前我并没有上过他的课。我对他的所有印象都来源于同学。某天自习课，他路过教室，看到窗边一同学玩手机，一把拉开窗跳讲去把手机抢了，还把那同学臭骂一顿。还有把女同学骂哭是经常的事。所有当时我上他的课都小心翼翼的。刚好那一周我坐第一排，然后他就点了我上去做题目，好像是划分物质的类别。当时我就蒙了，上去乱写一通。然后他讲评的时候，就在重复一句话，“又错了！”“又错了！”当时我觉得这也算是一场耻辱吧，学生时代的耻辱！然后我发奋，我一定会学会化学的！然后第二天，又打回原样了。因为，我睡了一觉~&lt;/p&gt;

&lt;p&gt;还有就是高三寒假，我背了好多书回去，想着最后一个寒假了，要好好努力。结果，你知道的，不断的睡觉……&lt;/p&gt;

&lt;p&gt;恩，扯了这么多无关紧要的事。就是想说明一个问题，对于我很严重的问题：我真的没有为什么奋斗过。某天晚上睡觉的时候，在想，如果明天是最后一天，我最后悔的是什么。当时想的是，啊，原来自己都没有奋斗过。这算是人生的一大遗憾吧。&lt;/p&gt;

&lt;p&gt;恩，这算是这段时间的一个目标。因为大三下学期，很多东西，不努力就要难过了。&lt;/p&gt;

&lt;p&gt;努力什么呢。吃饭？睡觉？恩，这是一点。吃好饭睡好觉才有饱满的精神去奋斗。虽然不知道将来的定位，但什么都学点吧。毕竟是有兴趣。技术这些东西，时刻都有新的，应该不会无聊吧。老爸老妈说公务员好，去考！但我是很讨厌公务员的生活啊。没办法，至少现在的我是这样想的。&lt;/p&gt;

&lt;p&gt;恩，学多点东西，锻炼身体。三月份有个百公里，虽然基友一直不建议我去，但还是想尝试下。毕竟，很多东西不去尝试，那根本不知道怎么回事。&lt;/p&gt;

&lt;p&gt;恩，扯远了。&lt;/p&gt;

&lt;p&gt;之前的我，考虑问题更多的是在考虑自己。突然想到父母老了啊，自己好像很少从父母的角度思考。我这样的年纪，父母肯定是担心我找不到好工作吧。以前说奋斗，说努力，总是睡一觉就过去了。之前总是认为如果某件事刺激我，那我肯定会奋发的。现在想着，最好没有这样的事情。努力无论什么时候都是自己的事，外物只是有时候有点推动作用而已。努力学好想学的东西然后找到好工作。&lt;/p&gt;

&lt;p&gt;恩，挺好的。努力吧。&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
